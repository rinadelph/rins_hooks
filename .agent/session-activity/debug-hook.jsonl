{"timestamp":"2025-07-22T00:17:12.662Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/task-blocker/index.js\",\"old_string\":\"  async execute(input) {\\n    try {\\n      // This hook is primarily for installation/configuration\\n      // The actual blocking is done via Claude Code permissions\\n      \\n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\\n        hook_event_name: input.hook_event_name,\\n        tool_name: input.tool_name,\\n        session_id: input.session_id\\n      });\\n\\n      return this.success({ \\n        message: 'Task blocker hook executed - blocking handled by permissions',\\n        usePermissions: this.config.usePermissions\\n      });\\n\\n    } catch (error) {\\n      this.logActivity('HOOK_ERROR', { \\n        error: error.message \\n      });\\n      return this.error(`Task blocker failed: ${error.message}`);\\n    }\\n  }\",\"new_string\":\"  execute(input) {\\n    try {\\n      // This hook is primarily for installation/configuration\\n      // The actual blocking is done via Claude Code permissions\\n      \\n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\\n        hook_event_name: input.hook_event_name,\\n        tool_name: input.tool_name,\\n        session_id: input.session_id\\n      });\\n\\n      return this.success({ \\n        message: 'Task blocker hook executed - blocking handled by permissions',\\n        usePermissions: this.config.usePermissions\\n      });\\n\\n    } catch (error) {\\n      this.logActivity('HOOK_ERROR', { \\n        error: error.message \\n      });\\n      return this.error(`Task blocker failed: ${error.message}`);\\n    }\\n  }\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/task-blocker/index.js\",\"oldString\":\"  async execute(input) {\\n    try {\\n      // This hook is primarily for installation/configuration\\n      // The actual blocking is done via Claude Code permissions\\n      \\n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\\n        hook_event_name: input.hook_event_name,\\n        tool_name: input.tool_name,\\n        session_id: input.session_id\\n      });\\n\\n      return this.success({ \\n        message: 'Task blocker hook executed - blocking handled by permissions',\\n        usePermissions: this.config.usePermissions\\n      });\\n\\n    } catch (error) {\\n      this.logActivity('HOOK_ERROR', { \\n        error: error.message \\n      });\\n      return this.error(`Task blocker failed: ${error.message}`);\\n    }\\n  }\",\"newString\":\"  execute(input) {\\n    try {\\n      // This hook is primarily for installation/configuration\\n      // The actual blocking is done via Claude Code permissions\\n      \\n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\\n        hook_event_name: input.hook_event_name,\\n        tool_name: input.tool_name,\\n        session_id: input.session_id\\n      });\\n\\n      return this.success({ \\n        message: 'Task blocker hook executed - blocking handled by permissions',\\n        usePermissions: this.config.usePermissions\\n      });\\n\\n    } catch (error) {\\n      this.logActivity('HOOK_ERROR', { \\n        error: error.message \\n      });\\n      return this.error(`Task blocker failed: ${error.message}`);\\n    }\\n  }\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst fs = require('fs');\\nconst path = require('path');\\nconst HookBase = require('../../src/hook-base');\\n\\nclass TaskBlockerHook extends HookBase {\\n  constructor(config = {}) {\\n    super('task-blocker', config);\\n    this.logFile = path.join(process.cwd(), 'task-blocker.log');\\n  }\\n\\n  getDefaultConfig() {\\n    return {\\n      enabled: true,\\n      matcher: '', // This hook manages permissions, not tool blocking\\n      timeout: 5,\\n      description: 'Configures Claude Code to block Task tool usage via permissions',\\n      blockMessage: 'Task tool usage is blocked. Please work directly without creating subagents.',\\n      logActivity: true,\\n      usePermissions: true // Use permission system instead of hook blocking\\n    };\\n  }\\n\\n  logActivity(message, data = {}) {\\n    if (!this.config.logActivity) return;\\n    \\n    const timestamp = new Date().toISOString();\\n    const logEntry = {\\n      timestamp,\\n      message,\\n      ...data\\n    };\\n\\n    try {\\n      fs.appendFileSync(this.logFile, `${JSON.stringify(logEntry, null, 2)}\\\\n\\\\n`);\\n    } catch (error) {\\n      console.warn(`Failed to log activity: ${error.message}`);\\n    }\\n  }\\n\\n  async execute(input) {\\n    try {\\n      // This hook is primarily for installation/configuration\\n      // The actual blocking is done via Claude Code permissions\\n      \\n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\\n        hook_event_name: input.hook_event_name,\\n        tool_name: input.tool_name,\\n        session_id: input.session_id\\n      });\\n\\n      return this.success({ \\n        message: 'Task blocker hook executed - blocking handled by permissions',\\n        usePermissions: this.config.usePermissions\\n      });\\n\\n    } catch (error) {\\n      this.logActivity('HOOK_ERROR', { \\n        error: error.message \\n      });\\n      return this.error(`Task blocker failed: ${error.message}`);\\n    }\\n  }\\n}\\n\\n// If called directly, execute the hook\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const input = await HookBase.parseInput();\\n      const hook = new TaskBlockerHook();\\n      await hook.execute(input);\\n      process.exit(0);\\n    } catch (error) {\\n      console.error(`Task blocker hook error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\\n\\nmodule.exports = TaskBlockerHook;\",\"structuredPatch\":[{\"oldStart\":39,\"oldLines\":7,\"newStart\":39,\"newLines\":7,\"lines\":[\"     }\",\"   }\",\" \",\"-  async execute(input) {\",\"+  execute(input) {\",\"     try {\",\"       // This hook is primarily for installation/configuration\",\"       // The actual blocking is done via Claude Code permissions\"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/task-blocker/index.js","old_string":"  async execute(input) {\n    try {\n      // This hook is primarily for installation/configuration\n      // The actual blocking is done via Claude Code permissions\n      \n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\n        hook_event_name: input.hook_event_name,\n        tool_name: input.tool_name,\n        session_id: input.session_id\n      });\n\n      return this.success({ \n        message: 'Task blocker hook executed - blocking handled by permissions',\n        usePermissions: this.config.usePermissions\n      });\n\n    } catch (error) {\n      this.logActivity('HOOK_ERROR', { \n        error: error.message \n      });\n      return this.error(`Task blocker failed: ${error.message}`);\n    }\n  }","new_string":"  execute(input) {\n    try {\n      // This hook is primarily for installation/configuration\n      // The actual blocking is done via Claude Code permissions\n      \n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\n        hook_event_name: input.hook_event_name,\n        tool_name: input.tool_name,\n        session_id: input.session_id\n      });\n\n      return this.success({ \n        message: 'Task blocker hook executed - blocking handled by permissions',\n        usePermissions: this.config.usePermissions\n      });\n\n    } catch (error) {\n      this.logActivity('HOOK_ERROR', { \n        error: error.message \n      });\n      return this.error(`Task blocker failed: ${error.message}`);\n    }\n  }"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/task-blocker/index.js","oldString":"  async execute(input) {\n    try {\n      // This hook is primarily for installation/configuration\n      // The actual blocking is done via Claude Code permissions\n      \n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\n        hook_event_name: input.hook_event_name,\n        tool_name: input.tool_name,\n        session_id: input.session_id\n      });\n\n      return this.success({ \n        message: 'Task blocker hook executed - blocking handled by permissions',\n        usePermissions: this.config.usePermissions\n      });\n\n    } catch (error) {\n      this.logActivity('HOOK_ERROR', { \n        error: error.message \n      });\n      return this.error(`Task blocker failed: ${error.message}`);\n    }\n  }","newString":"  execute(input) {\n    try {\n      // This hook is primarily for installation/configuration\n      // The actual blocking is done via Claude Code permissions\n      \n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\n        hook_event_name: input.hook_event_name,\n        tool_name: input.tool_name,\n        session_id: input.session_id\n      });\n\n      return this.success({ \n        message: 'Task blocker hook executed - blocking handled by permissions',\n        usePermissions: this.config.usePermissions\n      });\n\n    } catch (error) {\n      this.logActivity('HOOK_ERROR', { \n        error: error.message \n      });\n      return this.error(`Task blocker failed: ${error.message}`);\n    }\n  }","originalFile":"#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\nconst HookBase = require('../../src/hook-base');\n\nclass TaskBlockerHook extends HookBase {\n  constructor(config = {}) {\n    super('task-blocker', config);\n    this.logFile = path.join(process.cwd(), 'task-blocker.log');\n  }\n\n  getDefaultConfig() {\n    return {\n      enabled: true,\n      matcher: '', // This hook manages permissions, not tool blocking\n      timeout: 5,\n      description: 'Configures Claude Code to block Task tool usage via permissions',\n      blockMessage: 'Task tool usage is blocked. Please work directly without creating subagents.',\n      logActivity: true,\n      usePermissions: true // Use permission system instead of hook blocking\n    };\n  }\n\n  logActivity(message, data = {}) {\n    if (!this.config.logActivity) return;\n    \n    const timestamp = new Date().toISOString();\n    const logEntry = {\n      timestamp,\n      message,\n      ...data\n    };\n\n    try {\n      fs.appendFileSync(this.logFile, `${JSON.stringify(logEntry, null, 2)}\\n\\n`);\n    } catch (error) {\n      console.warn(`Failed to log activity: ${error.message}`);\n    }\n  }\n\n  async execute(input) {\n    try {\n      // This hook is primarily for installation/configuration\n      // The actual blocking is done via Claude Code permissions\n      \n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\n        hook_event_name: input.hook_event_name,\n        tool_name: input.tool_name,\n        session_id: input.session_id\n      });\n\n      return this.success({ \n        message: 'Task blocker hook executed - blocking handled by permissions',\n        usePermissions: this.config.usePermissions\n      });\n\n    } catch (error) {\n      this.logActivity('HOOK_ERROR', { \n        error: error.message \n      });\n      return this.error(`Task blocker failed: ${error.message}`);\n    }\n  }\n}\n\n// If called directly, execute the hook\nif (require.main === module) {\n  (async () => {\n    try {\n      const input = await HookBase.parseInput();\n      const hook = new TaskBlockerHook();\n      await hook.execute(input);\n      process.exit(0);\n    } catch (error) {\n      console.error(`Task blocker hook error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}\n\nmodule.exports = TaskBlockerHook;","structuredPatch":[{"oldStart":39,"oldLines":7,"newStart":39,"newLines":7,"lines":["     }","   }"," ","-  async execute(input) {","+  execute(input) {","     try {","       // This hook is primarily for installation/configuration","       // The actual blocking is done via Claude Code permissions"]}],"userModified":false,"replaceAll":false}},"process_pid":159874,"parent_pid":159873,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:17:19.897Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/task-blocker/index.js\",\"old_string\":\"// If called directly, execute the hook\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const input = await HookBase.parseInput();\\n      const hook = new TaskBlockerHook();\\n      await hook.execute(input);\\n      process.exit(0);\\n    } catch (error) {\\n      console.error(`Task blocker hook error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\",\"new_string\":\"// If called directly, execute the hook\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const input = await HookBase.parseInput();\\n      const hook = new TaskBlockerHook();\\n      hook.execute(input);\\n      process.exit(0);\\n    } catch (error) {\\n      console.error(`Task blocker hook error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/task-blocker/index.js\",\"oldString\":\"// If called directly, execute the hook\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const input = await HookBase.parseInput();\\n      const hook = new TaskBlockerHook();\\n      await hook.execute(input);\\n      process.exit(0);\\n    } catch (error) {\\n      console.error(`Task blocker hook error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\",\"newString\":\"// If called directly, execute the hook\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const input = await HookBase.parseInput();\\n      const hook = new TaskBlockerHook();\\n      hook.execute(input);\\n      process.exit(0);\\n    } catch (error) {\\n      console.error(`Task blocker hook error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst fs = require('fs');\\nconst path = require('path');\\nconst HookBase = require('../../src/hook-base');\\n\\nclass TaskBlockerHook extends HookBase {\\n  constructor(config = {}) {\\n    super('task-blocker', config);\\n    this.logFile = path.join(process.cwd(), 'task-blocker.log');\\n  }\\n\\n  getDefaultConfig() {\\n    return {\\n      enabled: true,\\n      matcher: '', // This hook manages permissions, not tool blocking\\n      timeout: 5,\\n      description: 'Configures Claude Code to block Task tool usage via permissions',\\n      blockMessage: 'Task tool usage is blocked. Please work directly without creating subagents.',\\n      logActivity: true,\\n      usePermissions: true // Use permission system instead of hook blocking\\n    };\\n  }\\n\\n  logActivity(message, data = {}) {\\n    if (!this.config.logActivity) return;\\n    \\n    const timestamp = new Date().toISOString();\\n    const logEntry = {\\n      timestamp,\\n      message,\\n      ...data\\n    };\\n\\n    try {\\n      fs.appendFileSync(this.logFile, `${JSON.stringify(logEntry, null, 2)}\\\\n\\\\n`);\\n    } catch (error) {\\n      console.warn(`Failed to log activity: ${error.message}`);\\n    }\\n  }\\n\\n  execute(input) {\\n    try {\\n      // This hook is primarily for installation/configuration\\n      // The actual blocking is done via Claude Code permissions\\n      \\n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\\n        hook_event_name: input.hook_event_name,\\n        tool_name: input.tool_name,\\n        session_id: input.session_id\\n      });\\n\\n      return this.success({ \\n        message: 'Task blocker hook executed - blocking handled by permissions',\\n        usePermissions: this.config.usePermissions\\n      });\\n\\n    } catch (error) {\\n      this.logActivity('HOOK_ERROR', { \\n        error: error.message \\n      });\\n      return this.error(`Task blocker failed: ${error.message}`);\\n    }\\n  }\\n}\\n\\n// If called directly, execute the hook\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const input = await HookBase.parseInput();\\n      const hook = new TaskBlockerHook();\\n      await hook.execute(input);\\n      process.exit(0);\\n    } catch (error) {\\n      console.error(`Task blocker hook error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\\n\\nmodule.exports = TaskBlockerHook;\",\"structuredPatch\":[{\"oldStart\":70,\"oldLines\":7,\"newStart\":70,\"newLines\":7,\"lines\":[\"     try {\",\"       const input = await HookBase.parseInput();\",\"       const hook = new TaskBlockerHook();\",\"-      await hook.execute(input);\",\"+      hook.execute(input);\",\"       process.exit(0);\",\"     } catch (error) {\",\"       console.error(`Task blocker hook error: ${error.message}`);\"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/task-blocker/index.js","old_string":"// If called directly, execute the hook\nif (require.main === module) {\n  (async () => {\n    try {\n      const input = await HookBase.parseInput();\n      const hook = new TaskBlockerHook();\n      await hook.execute(input);\n      process.exit(0);\n    } catch (error) {\n      console.error(`Task blocker hook error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}","new_string":"// If called directly, execute the hook\nif (require.main === module) {\n  (async () => {\n    try {\n      const input = await HookBase.parseInput();\n      const hook = new TaskBlockerHook();\n      hook.execute(input);\n      process.exit(0);\n    } catch (error) {\n      console.error(`Task blocker hook error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/task-blocker/index.js","oldString":"// If called directly, execute the hook\nif (require.main === module) {\n  (async () => {\n    try {\n      const input = await HookBase.parseInput();\n      const hook = new TaskBlockerHook();\n      await hook.execute(input);\n      process.exit(0);\n    } catch (error) {\n      console.error(`Task blocker hook error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}","newString":"// If called directly, execute the hook\nif (require.main === module) {\n  (async () => {\n    try {\n      const input = await HookBase.parseInput();\n      const hook = new TaskBlockerHook();\n      hook.execute(input);\n      process.exit(0);\n    } catch (error) {\n      console.error(`Task blocker hook error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}","originalFile":"#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\nconst HookBase = require('../../src/hook-base');\n\nclass TaskBlockerHook extends HookBase {\n  constructor(config = {}) {\n    super('task-blocker', config);\n    this.logFile = path.join(process.cwd(), 'task-blocker.log');\n  }\n\n  getDefaultConfig() {\n    return {\n      enabled: true,\n      matcher: '', // This hook manages permissions, not tool blocking\n      timeout: 5,\n      description: 'Configures Claude Code to block Task tool usage via permissions',\n      blockMessage: 'Task tool usage is blocked. Please work directly without creating subagents.',\n      logActivity: true,\n      usePermissions: true // Use permission system instead of hook blocking\n    };\n  }\n\n  logActivity(message, data = {}) {\n    if (!this.config.logActivity) return;\n    \n    const timestamp = new Date().toISOString();\n    const logEntry = {\n      timestamp,\n      message,\n      ...data\n    };\n\n    try {\n      fs.appendFileSync(this.logFile, `${JSON.stringify(logEntry, null, 2)}\\n\\n`);\n    } catch (error) {\n      console.warn(`Failed to log activity: ${error.message}`);\n    }\n  }\n\n  execute(input) {\n    try {\n      // This hook is primarily for installation/configuration\n      // The actual blocking is done via Claude Code permissions\n      \n      this.logActivity('TASK_BLOCKER_HOOK_TRIGGERED', {\n        hook_event_name: input.hook_event_name,\n        tool_name: input.tool_name,\n        session_id: input.session_id\n      });\n\n      return this.success({ \n        message: 'Task blocker hook executed - blocking handled by permissions',\n        usePermissions: this.config.usePermissions\n      });\n\n    } catch (error) {\n      this.logActivity('HOOK_ERROR', { \n        error: error.message \n      });\n      return this.error(`Task blocker failed: ${error.message}`);\n    }\n  }\n}\n\n// If called directly, execute the hook\nif (require.main === module) {\n  (async () => {\n    try {\n      const input = await HookBase.parseInput();\n      const hook = new TaskBlockerHook();\n      await hook.execute(input);\n      process.exit(0);\n    } catch (error) {\n      console.error(`Task blocker hook error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}\n\nmodule.exports = TaskBlockerHook;","structuredPatch":[{"oldStart":70,"oldLines":7,"newStart":70,"newLines":7,"lines":["     try {","       const input = await HookBase.parseInput();","       const hook = new TaskBlockerHook();","-      await hook.execute(input);","+      hook.execute(input);","       process.exit(0);","     } catch (error) {","       console.error(`Task blocker hook error: ${error.message}`);"]}],"userModified":false,"replaceAll":false}},"process_pid":159925,"parent_pid":159924,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:20:55.479Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/git-agentmcp/index.js\",\"old_string\":\"    const { tool_name, tool_input, session_id } = input;\",\"new_string\":\"    const { tool_name, tool_input } = input;\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/git-agentmcp/index.js\",\"oldString\":\"    const { tool_name, tool_input, session_id } = input;\",\"newString\":\"    const { tool_name, tool_input } = input;\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst fs = require('fs');\\nconst path = require('path');\\nconst { spawn } = require('child_process');\\n\\n/**\\n * Git Agent-MCP Hook for Claude Code - Multi-Agent Git Integration\\n * \\n * Features:\\n * - PID tracking in commit messages for easy revert\\n * - Session-based agent identification  \\n * - Agent-MCP .agent directory integration\\n * - Multi-agent coordination and activity logging\\n * - Direct Claude Code compliance (no HookBase dependency)\\n */\\n\\n// Configuration\\nconst CONFIG = {\\n  enabled: true,\\n  lockTimeout: 600, // 10 minutes\\n  commitMessageTemplate: `{{action}}: {{toolName}} modified {{fileName}}\\n\\nSession: {{sessionId}}\\nPID: {{pid}} (parent: {{parentPid}})\\nTimestamp: {{timestamp}}\\nFile: {{filePath}}\\nTool: {{toolName}}\\n\\n# Revert: git log --grep=\\\"PID: {{pid}}\\\"\\nðŸ¤– Generated with Claude Code via rins_hooks\\nCo-Authored-By: Claude <noreply@anthropic.com>`,\\n  excludePatterns: [\\n    /\\\\.log$/,\\n    /\\\\.tmp$/,\\n    /\\\\.temp$/,\\n    /\\\\.lock$/,\\n    /\\\\.env/,\\n    /\\\\.git\\\\//,\\n    /\\\\.agent/,\\n    /node_modules\\\\//,\\n    /\\\\.pyc$/,\\n    /__pycache__\\\\//\\n  ],\\n  skipEmptyCommits: true,\\n  maxCommitMessageLength: 800\\n};\\n\\n// Utility functions\\nfunction ensureAgentDirectory() {\\n  const agentDir = path.join(process.cwd(), '.agent');\\n  \\n  try {\\n    if (!fs.existsSync(agentDir)) {\\n      // Create .agent directory with standard structure\\n      fs.mkdirSync(agentDir, { recursive: true });\\n      \\n      // Create subdirectories that don't conflict with Agent-MCP\\n      const subdirs = ['session-activity'];\\n      for (const subdir of subdirs) {\\n        const subdirPath = path.join(agentDir, subdir);\\n        if (!fs.existsSync(subdirPath)) {\\n          fs.mkdirSync(subdirPath, { recursive: true });\\n        }\\n      }\\n      \\n      // Create minimal config if none exists (compatible with Agent-MCP)\\n      const configPath = path.join(agentDir, 'config.json');\\n      if (!fs.existsSync(configPath)) {\\n        const minimalConfig = {\\n          project_name: path.basename(process.cwd()),\\n          created_at: new Date().toISOString(),\\n          created_by: 'rins_hooks_auto_commit',\\n          hook_version: '1.0.0'\\n        };\\n        fs.writeFileSync(configPath, JSON.stringify(minimalConfig, null, 2));\\n      }\\n    }\\n    \\n    return true;\\n  } catch (error) {\\n    // Silent failure - don't block git operations\\n    return false;\\n  }\\n}\\n\\nfunction extractFilePath(toolInput) {\\n  return toolInput.file_path || \\n         toolInput.filePath ||\\n         (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\\n         null;\\n}\\n\\nfunction extractAgentId(input) {\\n  return input.session_id || `session-${process.ppid}`;\\n}\\n\\nfunction shouldExcludeFile(filePath) {\\n  const fileName = path.basename(filePath);\\n  const relativePath = path.relative(process.cwd(), filePath);\\n  const normalizedPath = relativePath.replace(/\\\\\\\\/g, '/');\\n\\n  return CONFIG.excludePatterns.some(pattern => {\\n    const regex = new RegExp(pattern.source.replace(/\\\\*\\\\*/g, '.*').replace(/\\\\*/g, '[^/\\\\\\\\\\\\\\\\]*'));\\n    return regex.test(fileName) || regex.test(normalizedPath);\\n  });\\n}\\n\\nfunction generateCommitMessage(toolName, filePath, input) {\\n  const fileName = path.basename(filePath);\\n  const agentId = extractAgentId(input);\\n  const timestamp = new Date().toISOString();\\n  \\n  // Determine action based on tool\\n  let action = 'feat';\\n  if (toolName === 'Edit') action = 'feat';\\n  else if (toolName === 'Write') action = 'feat';\\n  else if (toolName === 'MultiEdit') action = 'feat';\\n  \\n  let message = CONFIG.commitMessageTemplate\\n    .replace(/\\\\{\\\\{action\\\\}\\\\}/g, action)\\n    .replace(/\\\\{\\\\{toolName\\\\}\\\\}/g, toolName)\\n    .replace(/\\\\{\\\\{fileName\\\\}\\\\}/g, fileName)\\n    .replace(/\\\\{\\\\{filePath\\\\}\\\\}/g, filePath)\\n    .replace(/\\\\{\\\\{sessionId\\\\}\\\\}/g, agentId)\\n    .replace(/\\\\{\\\\{pid\\\\}\\\\}/g, process.pid)\\n    .replace(/\\\\{\\\\{parentPid\\\\}\\\\}/g, process.ppid)\\n    .replace(/\\\\{\\\\{timestamp\\\\}\\\\}/g, timestamp);\\n\\n  // Truncate if too long\\n  if (message.length > CONFIG.maxCommitMessageLength) {\\n    message = `${message.substring(0, CONFIG.maxCommitMessageLength - 3)}...`;\\n  }\\n\\n  return message;\\n}\\n\\nfunction runGitCommand(args) {\\n  return new Promise((resolve, reject) => {\\n    const git = spawn('git', args, {\\n      stdio: ['pipe', 'pipe', 'pipe'],\\n      cwd: process.cwd()\\n    });\\n\\n    let stdout = '';\\n    let stderr = '';\\n\\n    git.stdout.on('data', (data) => {\\n      stdout += data.toString();\\n    });\\n\\n    git.stderr.on('data', (data) => {\\n      stderr += data.toString();\\n    });\\n\\n    git.on('close', (code) => {\\n      if (code === 0) {\\n        resolve(stdout);\\n      } else {\\n        reject(new Error(`Git command failed: ${stderr}`));\\n      }\\n    });\\n\\n    git.on('error', (error) => {\\n      reject(error);\\n    });\\n  });\\n}\\n\\nasync function isGitRepository() {\\n  try {\\n    await runGitCommand(['rev-parse', '--git-dir']);\\n    return true;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\n\\nasync function hasChangesToCommit() {\\n  try {\\n    const status = await runGitCommand(['status', '--porcelain']);\\n    return status.trim().length > 0;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\n\\nfunction logCommitActivity(agentId, filePath, commitHash, toolName) {\\n  try {\\n    ensureAgentDirectory();\\n    \\n    const activityDir = path.join(process.cwd(), '.agent', 'session-activity');\\n    const logFile = path.join(activityDir, 'git-commits.jsonl');\\n    \\n    const logEntry = {\\n      timestamp: new Date().toISOString(),\\n      session_id: agentId,\\n      pid: process.pid,\\n      parent_pid: process.ppid,\\n      commit_hash: commitHash,\\n      file_path: filePath,\\n      tool_name: toolName,\\n      working_directory: process.cwd()\\n    };\\n    \\n    fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\\\\n');\\n  } catch (error) {\\n    // Silent failure - don't block operations\\n  }\\n}\\n\\n// Parse input from stdin\\nfunction parseInput() {\\n  return new Promise((resolve, reject) => {\\n    let input = '';\\n    \\n    process.stdin.on('data', (chunk) => {\\n      input += chunk.toString();\\n    });\\n    \\n    process.stdin.on('end', () => {\\n      try {\\n        const data = JSON.parse(input);\\n        resolve(data);\\n      } catch (error) {\\n        reject(new Error(`Invalid JSON input: ${error.message}`));\\n      }\\n    });\\n    \\n    process.stdin.on('error', reject);\\n  });\\n}\\n\\n// Main execution function\\nasync function main() {\\n  try {\\n    // Parse input from Claude Code\\n    const input = await parseInput();\\n    const { tool_name, tool_input, session_id } = input;\\n    \\n    // Only handle file modification tools\\n    if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\\n      process.exit(0);\\n    }\\n\\n    const filePath = extractFilePath(tool_input);\\n    if (!filePath) {\\n      process.exit(0);\\n    }\\n\\n    // Check if we're in a git repository\\n    if (!await isGitRepository()) {\\n      console.log('Not in a git repository, skipping commit');\\n      process.exit(0);\\n    }\\n\\n    // Check if file should be excluded\\n    if (shouldExcludeFile(filePath)) {\\n      console.log(`File excluded from auto-commit: ${filePath}`);\\n      process.exit(0);\\n    }\\n\\n    // Check if file exists\\n    if (!fs.existsSync(filePath)) {\\n      console.error(`File does not exist: ${filePath}`);\\n      process.exit(1);\\n    }\\n\\n    // Add file to git\\n    await runGitCommand(['add', filePath]);\\n\\n    // Check if there are changes to commit\\n    if (CONFIG.skipEmptyCommits && !await hasChangesToCommit()) {\\n      console.log('No changes to commit');\\n      process.exit(0);\\n    }\\n\\n    // Generate commit message\\n    const commitMessage = generateCommitMessage(tool_name, filePath, input);\\n\\n    // Create commit\\n    await runGitCommand(['commit', '-m', commitMessage]);\\n\\n    // Get commit hash for logging\\n    const commitHash = await runGitCommand(['rev-parse', 'HEAD']);\\n    \\n    // Log commit activity to .agent directory\\n    logCommitActivity(extractAgentId(input), filePath, commitHash.trim(), tool_name);\\n\\n    console.log(`Successfully committed ${path.basename(filePath)} with PID tracking`);\\n    process.exit(0);\\n\\n  } catch (error) {\\n    console.error(`Auto-commit failed: ${error.message}`);\\n    process.exit(1);\\n  }\\n}\\n\\n// Execute if called directly\\nif (require.main === module) {\\n  main();\\n}\\n\\nmodule.exports = { main, parseInput, extractAgentId };\",\"structuredPatch\":[{\"oldStart\":236,\"oldLines\":7,\"newStart\":236,\"newLines\":7,\"lines\":[\"   try {\",\"     // Parse input from Claude Code\",\"     const input = await parseInput();\",\"-    const { tool_name, tool_input, session_id } = input;\",\"+    const { tool_name, tool_input } = input;\",\"     \",\"     // Only handle file modification tools\",\"     if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/git-agentmcp/index.js","old_string":"    const { tool_name, tool_input, session_id } = input;","new_string":"    const { tool_name, tool_input } = input;"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/git-agentmcp/index.js","oldString":"    const { tool_name, tool_input, session_id } = input;","newString":"    const { tool_name, tool_input } = input;","originalFile":"#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\nconst { spawn } = require('child_process');\n\n/**\n * Git Agent-MCP Hook for Claude Code - Multi-Agent Git Integration\n * \n * Features:\n * - PID tracking in commit messages for easy revert\n * - Session-based agent identification  \n * - Agent-MCP .agent directory integration\n * - Multi-agent coordination and activity logging\n * - Direct Claude Code compliance (no HookBase dependency)\n */\n\n// Configuration\nconst CONFIG = {\n  enabled: true,\n  lockTimeout: 600, // 10 minutes\n  commitMessageTemplate: `{{action}}: {{toolName}} modified {{fileName}}\n\nSession: {{sessionId}}\nPID: {{pid}} (parent: {{parentPid}})\nTimestamp: {{timestamp}}\nFile: {{filePath}}\nTool: {{toolName}}\n\n# Revert: git log --grep=\"PID: {{pid}}\"\nðŸ¤– Generated with Claude Code via rins_hooks\nCo-Authored-By: Claude <noreply@anthropic.com>`,\n  excludePatterns: [\n    /\\.log$/,\n    /\\.tmp$/,\n    /\\.temp$/,\n    /\\.lock$/,\n    /\\.env/,\n    /\\.git\\//,\n    /\\.agent/,\n    /node_modules\\//,\n    /\\.pyc$/,\n    /__pycache__\\//\n  ],\n  skipEmptyCommits: true,\n  maxCommitMessageLength: 800\n};\n\n// Utility functions\nfunction ensureAgentDirectory() {\n  const agentDir = path.join(process.cwd(), '.agent');\n  \n  try {\n    if (!fs.existsSync(agentDir)) {\n      // Create .agent directory with standard structure\n      fs.mkdirSync(agentDir, { recursive: true });\n      \n      // Create subdirectories that don't conflict with Agent-MCP\n      const subdirs = ['session-activity'];\n      for (const subdir of subdirs) {\n        const subdirPath = path.join(agentDir, subdir);\n        if (!fs.existsSync(subdirPath)) {\n          fs.mkdirSync(subdirPath, { recursive: true });\n        }\n      }\n      \n      // Create minimal config if none exists (compatible with Agent-MCP)\n      const configPath = path.join(agentDir, 'config.json');\n      if (!fs.existsSync(configPath)) {\n        const minimalConfig = {\n          project_name: path.basename(process.cwd()),\n          created_at: new Date().toISOString(),\n          created_by: 'rins_hooks_auto_commit',\n          hook_version: '1.0.0'\n        };\n        fs.writeFileSync(configPath, JSON.stringify(minimalConfig, null, 2));\n      }\n    }\n    \n    return true;\n  } catch (error) {\n    // Silent failure - don't block git operations\n    return false;\n  }\n}\n\nfunction extractFilePath(toolInput) {\n  return toolInput.file_path || \n         toolInput.filePath ||\n         (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\n         null;\n}\n\nfunction extractAgentId(input) {\n  return input.session_id || `session-${process.ppid}`;\n}\n\nfunction shouldExcludeFile(filePath) {\n  const fileName = path.basename(filePath);\n  const relativePath = path.relative(process.cwd(), filePath);\n  const normalizedPath = relativePath.replace(/\\\\/g, '/');\n\n  return CONFIG.excludePatterns.some(pattern => {\n    const regex = new RegExp(pattern.source.replace(/\\*\\*/g, '.*').replace(/\\*/g, '[^/\\\\\\\\]*'));\n    return regex.test(fileName) || regex.test(normalizedPath);\n  });\n}\n\nfunction generateCommitMessage(toolName, filePath, input) {\n  const fileName = path.basename(filePath);\n  const agentId = extractAgentId(input);\n  const timestamp = new Date().toISOString();\n  \n  // Determine action based on tool\n  let action = 'feat';\n  if (toolName === 'Edit') action = 'feat';\n  else if (toolName === 'Write') action = 'feat';\n  else if (toolName === 'MultiEdit') action = 'feat';\n  \n  let message = CONFIG.commitMessageTemplate\n    .replace(/\\{\\{action\\}\\}/g, action)\n    .replace(/\\{\\{toolName\\}\\}/g, toolName)\n    .replace(/\\{\\{fileName\\}\\}/g, fileName)\n    .replace(/\\{\\{filePath\\}\\}/g, filePath)\n    .replace(/\\{\\{sessionId\\}\\}/g, agentId)\n    .replace(/\\{\\{pid\\}\\}/g, process.pid)\n    .replace(/\\{\\{parentPid\\}\\}/g, process.ppid)\n    .replace(/\\{\\{timestamp\\}\\}/g, timestamp);\n\n  // Truncate if too long\n  if (message.length > CONFIG.maxCommitMessageLength) {\n    message = `${message.substring(0, CONFIG.maxCommitMessageLength - 3)}...`;\n  }\n\n  return message;\n}\n\nfunction runGitCommand(args) {\n  return new Promise((resolve, reject) => {\n    const git = spawn('git', args, {\n      stdio: ['pipe', 'pipe', 'pipe'],\n      cwd: process.cwd()\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    git.stdout.on('data', (data) => {\n      stdout += data.toString();\n    });\n\n    git.stderr.on('data', (data) => {\n      stderr += data.toString();\n    });\n\n    git.on('close', (code) => {\n      if (code === 0) {\n        resolve(stdout);\n      } else {\n        reject(new Error(`Git command failed: ${stderr}`));\n      }\n    });\n\n    git.on('error', (error) => {\n      reject(error);\n    });\n  });\n}\n\nasync function isGitRepository() {\n  try {\n    await runGitCommand(['rev-parse', '--git-dir']);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nasync function hasChangesToCommit() {\n  try {\n    const status = await runGitCommand(['status', '--porcelain']);\n    return status.trim().length > 0;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction logCommitActivity(agentId, filePath, commitHash, toolName) {\n  try {\n    ensureAgentDirectory();\n    \n    const activityDir = path.join(process.cwd(), '.agent', 'session-activity');\n    const logFile = path.join(activityDir, 'git-commits.jsonl');\n    \n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      session_id: agentId,\n      pid: process.pid,\n      parent_pid: process.ppid,\n      commit_hash: commitHash,\n      file_path: filePath,\n      tool_name: toolName,\n      working_directory: process.cwd()\n    };\n    \n    fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\\n');\n  } catch (error) {\n    // Silent failure - don't block operations\n  }\n}\n\n// Parse input from stdin\nfunction parseInput() {\n  return new Promise((resolve, reject) => {\n    let input = '';\n    \n    process.stdin.on('data', (chunk) => {\n      input += chunk.toString();\n    });\n    \n    process.stdin.on('end', () => {\n      try {\n        const data = JSON.parse(input);\n        resolve(data);\n      } catch (error) {\n        reject(new Error(`Invalid JSON input: ${error.message}`));\n      }\n    });\n    \n    process.stdin.on('error', reject);\n  });\n}\n\n// Main execution function\nasync function main() {\n  try {\n    // Parse input from Claude Code\n    const input = await parseInput();\n    const { tool_name, tool_input, session_id } = input;\n    \n    // Only handle file modification tools\n    if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\n      process.exit(0);\n    }\n\n    const filePath = extractFilePath(tool_input);\n    if (!filePath) {\n      process.exit(0);\n    }\n\n    // Check if we're in a git repository\n    if (!await isGitRepository()) {\n      console.log('Not in a git repository, skipping commit');\n      process.exit(0);\n    }\n\n    // Check if file should be excluded\n    if (shouldExcludeFile(filePath)) {\n      console.log(`File excluded from auto-commit: ${filePath}`);\n      process.exit(0);\n    }\n\n    // Check if file exists\n    if (!fs.existsSync(filePath)) {\n      console.error(`File does not exist: ${filePath}`);\n      process.exit(1);\n    }\n\n    // Add file to git\n    await runGitCommand(['add', filePath]);\n\n    // Check if there are changes to commit\n    if (CONFIG.skipEmptyCommits && !await hasChangesToCommit()) {\n      console.log('No changes to commit');\n      process.exit(0);\n    }\n\n    // Generate commit message\n    const commitMessage = generateCommitMessage(tool_name, filePath, input);\n\n    // Create commit\n    await runGitCommand(['commit', '-m', commitMessage]);\n\n    // Get commit hash for logging\n    const commitHash = await runGitCommand(['rev-parse', 'HEAD']);\n    \n    // Log commit activity to .agent directory\n    logCommitActivity(extractAgentId(input), filePath, commitHash.trim(), tool_name);\n\n    console.log(`Successfully committed ${path.basename(filePath)} with PID tracking`);\n    process.exit(0);\n\n  } catch (error) {\n    console.error(`Auto-commit failed: ${error.message}`);\n    process.exit(1);\n  }\n}\n\n// Execute if called directly\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = { main, parseInput, extractAgentId };","structuredPatch":[{"oldStart":236,"oldLines":7,"newStart":236,"newLines":7,"lines":["   try {","     // Parse input from Claude Code","     const input = await parseInput();","-    const { tool_name, tool_input, session_id } = input;","+    const { tool_name, tool_input } = input;","     ","     // Only handle file modification tools","     if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {"]}],"userModified":false,"replaceAll":false}},"process_pid":160754,"parent_pid":160753,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:21:05.984Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/agent-registry/index.js\",\"old_string\":\"    const { tool_name, tool_input, session_id } = input;\",\"new_string\":\"    const { tool_name, tool_input } = input;\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/agent-registry/index.js\",\"oldString\":\"    const { tool_name, tool_input, session_id } = input;\",\"newString\":\"    const { tool_name, tool_input } = input;\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst fs = require('fs');\\nconst path = require('path');\\n\\n/**\\n * Agent Registry Hook for Claude Code - Agent-MCP Integration\\n * \\n * Features:\\n * - Register Claude Code sessions in .agent/registry.json\\n * - Robust .agent directory creation (compatible with Agent-MCP)\\n * - Auto-cleanup of stale sessions after 3 minutes\\n * - Activity logging for Agent-MCP monitoring\\n */\\n\\n// Configuration\\nconst CONFIG = {\\n  registryFile: '.agent/registry.json',\\n  sessionTimeoutMinutes: 3,\\n  activityDirectory: '.agent/session-activity',\\n  logAllActivity: true\\n};\\n\\n// Utility functions\\nfunction ensureAgentDirectory() {\\n  const agentDir = path.join(process.cwd(), '.agent');\\n  \\n  try {\\n    if (!fs.existsSync(agentDir)) {\\n      // Create .agent directory with Agent-MCP compatible structure\\n      fs.mkdirSync(agentDir, { recursive: true });\\n      \\n      // Create subdirectories that don't conflict with Agent-MCP\\n      const subdirs = ['session-activity'];\\n      for (const subdir of subdirs) {\\n        const subdirPath = path.join(agentDir, subdir);\\n        if (!fs.existsSync(subdirPath)) {\\n          fs.mkdirSync(subdirPath, { recursive: true });\\n        }\\n      }\\n      \\n      // Create compatible config if none exists\\n      const configPath = path.join(agentDir, 'config.json');\\n      if (!fs.existsSync(configPath)) {\\n        const compatibleConfig = {\\n          project_name: path.basename(process.cwd()),\\n          created_at: new Date().toISOString(),\\n          created_by: 'rins_hooks_agent_registry',\\n          hook_version: '1.0.0',\\n          agent_mcp_compatible: true\\n        };\\n        fs.writeFileSync(configPath, JSON.stringify(compatibleConfig, null, 2));\\n      }\\n    }\\n    \\n    // Ensure session-activity directory exists\\n    const activityDir = path.join(process.cwd(), CONFIG.activityDirectory);\\n    if (!fs.existsSync(activityDir)) {\\n      fs.mkdirSync(activityDir, { recursive: true });\\n    }\\n    \\n    return true;\\n  } catch (error) {\\n    // Silent failure - don't block operations\\n    return false;\\n  }\\n}\\n\\nfunction extractFilePath(toolInput) {\\n  return toolInput.file_path || \\n         toolInput.filePath ||\\n         (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\\n         null;\\n}\\n\\nfunction extractAgentId(input) {\\n  return input.session_id || `session-${process.ppid}`;\\n}\\n\\nfunction readRegistry() {\\n  const registryPath = path.join(process.cwd(), CONFIG.registryFile);\\n  \\n  try {\\n    if (fs.existsSync(registryPath)) {\\n      const data = fs.readFileSync(registryPath, 'utf8');\\n      return JSON.parse(data);\\n    }\\n  } catch (error) {\\n    // Return empty registry on error\\n  }\\n  \\n  return {\\n    sessions: {},\\n    cleanup: {\\n      last_cleanup: Date.now(),\\n      timeout_minutes: CONFIG.sessionTimeoutMinutes\\n    }\\n  };\\n}\\n\\nfunction writeRegistry(registry) {\\n  const registryPath = path.join(process.cwd(), CONFIG.registryFile);\\n  const lockFile = registryPath + '.lock';\\n  \\n  try {\\n    // Simple lock mechanism\\n    if (fs.existsSync(lockFile)) {\\n      return false; // Another process is updating\\n    }\\n    \\n    fs.writeFileSync(lockFile, '');\\n    \\n    // Atomic write\\n    const tempPath = registryPath + '.tmp';\\n    fs.writeFileSync(tempPath, JSON.stringify(registry, null, 2));\\n    fs.renameSync(tempPath, registryPath);\\n    \\n    fs.unlinkSync(lockFile);\\n    return true;\\n  } catch (error) {\\n    // Clean up lock on error\\n    try {\\n      if (fs.existsSync(lockFile)) {\\n        fs.unlinkSync(lockFile);\\n      }\\n    } catch (e) {\\n      // Ignore cleanup errors\\n    }\\n    return false;\\n  }\\n}\\n\\nfunction cleanupStaleEntries(registry) {\\n  const now = Date.now();\\n  const timeoutMs = CONFIG.sessionTimeoutMinutes * 60 * 1000;\\n  const activeSessions = {};\\n  \\n  for (const [sessionId, sessionData] of Object.entries(registry.sessions)) {\\n    if (now - sessionData.last_activity < timeoutMs) {\\n      activeSessions[sessionId] = sessionData;\\n    }\\n  }\\n  \\n  registry.sessions = activeSessions;\\n  registry.cleanup.last_cleanup = now;\\n  \\n  return registry;\\n}\\n\\nfunction updateAgentRegistry(input, toolName, filePath) {\\n  try {\\n    ensureAgentDirectory();\\n    \\n    const agentId = extractAgentId(input);\\n    const now = Date.now();\\n    \\n    // Read current registry\\n    let registry = readRegistry();\\n    \\n    // Clean up stale entries\\n    registry = cleanupStaleEntries(registry);\\n    \\n    // Update current session\\n    const sessionData = {\\n      session_id: agentId,\\n      pid: process.pid,\\n      parent_pid: process.ppid,\\n      first_seen: registry.sessions[agentId]?.first_seen || now,\\n      last_activity: now,\\n      tool_name: toolName,\\n      file_path: filePath,\\n      working_directory: process.cwd(),\\n      hook_event: input.hook_event_name || 'PostToolUse'\\n    };\\n    \\n    registry.sessions[agentId] = sessionData;\\n    \\n    // Write registry back\\n    const success = writeRegistry(registry);\\n    \\n    if (success && CONFIG.logAllActivity) {\\n      logSessionActivity(agentId, toolName, filePath, 'registry_updated');\\n    }\\n    \\n    return success;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\n\\nfunction logSessionActivity(agentId, toolName, filePath, action) {\\n  try {\\n    const activityDir = path.join(process.cwd(), CONFIG.activityDirectory);\\n    const logFile = path.join(activityDir, 'registry-activity.jsonl');\\n    \\n    const logEntry = {\\n      timestamp: new Date().toISOString(),\\n      session_id: agentId,\\n      pid: process.pid,\\n      parent_pid: process.ppid,\\n      action: action,\\n      tool_name: toolName,\\n      file_path: filePath,\\n      working_directory: process.cwd()\\n    };\\n    \\n    fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\\\\n');\\n  } catch (error) {\\n    // Silent failure - don't block operations\\n  }\\n}\\n\\n// Parse input from stdin\\nfunction parseInput() {\\n  return new Promise((resolve, reject) => {\\n    let input = '';\\n    \\n    process.stdin.on('data', (chunk) => {\\n      input += chunk.toString();\\n    });\\n    \\n    process.stdin.on('end', () => {\\n      try {\\n        const data = JSON.parse(input);\\n        resolve(data);\\n      } catch (error) {\\n        reject(new Error(`Invalid JSON input: ${error.message}`));\\n      }\\n    });\\n    \\n    process.stdin.on('error', reject);\\n  });\\n}\\n\\n// Main execution function\\nasync function main() {\\n  try {\\n    // Parse input from Claude Code\\n    const input = await parseInput();\\n    const { tool_name, tool_input, session_id } = input;\\n    \\n    // Only handle file modification tools\\n    if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\\n      process.exit(0);\\n    }\\n\\n    const filePath = extractFilePath(tool_input);\\n    if (!filePath) {\\n      process.exit(0);\\n    }\\n\\n    // Update agent registry\\n    const success = updateAgentRegistry(input, tool_name, filePath);\\n    \\n    if (success) {\\n      console.log(`Agent session registered: ${extractAgentId(input)}`);\\n    } else {\\n      console.log(`Agent registry update skipped (concurrent access)`);\\n    }\\n    \\n    process.exit(0);\\n\\n  } catch (error) {\\n    console.error(`Agent registry failed: ${error.message}`);\\n    process.exit(1);\\n  }\\n}\\n\\n// Execute if called directly\\nif (require.main === module) {\\n  main();\\n}\\n\\nmodule.exports = { main, parseInput, extractAgentId, updateAgentRegistry };\",\"structuredPatch\":[{\"oldStart\":237,\"oldLines\":7,\"newStart\":237,\"newLines\":7,\"lines\":[\"   try {\",\"     // Parse input from Claude Code\",\"     const input = await parseInput();\",\"-    const { tool_name, tool_input, session_id } = input;\",\"+    const { tool_name, tool_input } = input;\",\"     \",\"     // Only handle file modification tools\",\"     if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/agent-registry/index.js","old_string":"    const { tool_name, tool_input, session_id } = input;","new_string":"    const { tool_name, tool_input } = input;"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/agent-registry/index.js","oldString":"    const { tool_name, tool_input, session_id } = input;","newString":"    const { tool_name, tool_input } = input;","originalFile":"#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Agent Registry Hook for Claude Code - Agent-MCP Integration\n * \n * Features:\n * - Register Claude Code sessions in .agent/registry.json\n * - Robust .agent directory creation (compatible with Agent-MCP)\n * - Auto-cleanup of stale sessions after 3 minutes\n * - Activity logging for Agent-MCP monitoring\n */\n\n// Configuration\nconst CONFIG = {\n  registryFile: '.agent/registry.json',\n  sessionTimeoutMinutes: 3,\n  activityDirectory: '.agent/session-activity',\n  logAllActivity: true\n};\n\n// Utility functions\nfunction ensureAgentDirectory() {\n  const agentDir = path.join(process.cwd(), '.agent');\n  \n  try {\n    if (!fs.existsSync(agentDir)) {\n      // Create .agent directory with Agent-MCP compatible structure\n      fs.mkdirSync(agentDir, { recursive: true });\n      \n      // Create subdirectories that don't conflict with Agent-MCP\n      const subdirs = ['session-activity'];\n      for (const subdir of subdirs) {\n        const subdirPath = path.join(agentDir, subdir);\n        if (!fs.existsSync(subdirPath)) {\n          fs.mkdirSync(subdirPath, { recursive: true });\n        }\n      }\n      \n      // Create compatible config if none exists\n      const configPath = path.join(agentDir, 'config.json');\n      if (!fs.existsSync(configPath)) {\n        const compatibleConfig = {\n          project_name: path.basename(process.cwd()),\n          created_at: new Date().toISOString(),\n          created_by: 'rins_hooks_agent_registry',\n          hook_version: '1.0.0',\n          agent_mcp_compatible: true\n        };\n        fs.writeFileSync(configPath, JSON.stringify(compatibleConfig, null, 2));\n      }\n    }\n    \n    // Ensure session-activity directory exists\n    const activityDir = path.join(process.cwd(), CONFIG.activityDirectory);\n    if (!fs.existsSync(activityDir)) {\n      fs.mkdirSync(activityDir, { recursive: true });\n    }\n    \n    return true;\n  } catch (error) {\n    // Silent failure - don't block operations\n    return false;\n  }\n}\n\nfunction extractFilePath(toolInput) {\n  return toolInput.file_path || \n         toolInput.filePath ||\n         (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\n         null;\n}\n\nfunction extractAgentId(input) {\n  return input.session_id || `session-${process.ppid}`;\n}\n\nfunction readRegistry() {\n  const registryPath = path.join(process.cwd(), CONFIG.registryFile);\n  \n  try {\n    if (fs.existsSync(registryPath)) {\n      const data = fs.readFileSync(registryPath, 'utf8');\n      return JSON.parse(data);\n    }\n  } catch (error) {\n    // Return empty registry on error\n  }\n  \n  return {\n    sessions: {},\n    cleanup: {\n      last_cleanup: Date.now(),\n      timeout_minutes: CONFIG.sessionTimeoutMinutes\n    }\n  };\n}\n\nfunction writeRegistry(registry) {\n  const registryPath = path.join(process.cwd(), CONFIG.registryFile);\n  const lockFile = registryPath + '.lock';\n  \n  try {\n    // Simple lock mechanism\n    if (fs.existsSync(lockFile)) {\n      return false; // Another process is updating\n    }\n    \n    fs.writeFileSync(lockFile, '');\n    \n    // Atomic write\n    const tempPath = registryPath + '.tmp';\n    fs.writeFileSync(tempPath, JSON.stringify(registry, null, 2));\n    fs.renameSync(tempPath, registryPath);\n    \n    fs.unlinkSync(lockFile);\n    return true;\n  } catch (error) {\n    // Clean up lock on error\n    try {\n      if (fs.existsSync(lockFile)) {\n        fs.unlinkSync(lockFile);\n      }\n    } catch (e) {\n      // Ignore cleanup errors\n    }\n    return false;\n  }\n}\n\nfunction cleanupStaleEntries(registry) {\n  const now = Date.now();\n  const timeoutMs = CONFIG.sessionTimeoutMinutes * 60 * 1000;\n  const activeSessions = {};\n  \n  for (const [sessionId, sessionData] of Object.entries(registry.sessions)) {\n    if (now - sessionData.last_activity < timeoutMs) {\n      activeSessions[sessionId] = sessionData;\n    }\n  }\n  \n  registry.sessions = activeSessions;\n  registry.cleanup.last_cleanup = now;\n  \n  return registry;\n}\n\nfunction updateAgentRegistry(input, toolName, filePath) {\n  try {\n    ensureAgentDirectory();\n    \n    const agentId = extractAgentId(input);\n    const now = Date.now();\n    \n    // Read current registry\n    let registry = readRegistry();\n    \n    // Clean up stale entries\n    registry = cleanupStaleEntries(registry);\n    \n    // Update current session\n    const sessionData = {\n      session_id: agentId,\n      pid: process.pid,\n      parent_pid: process.ppid,\n      first_seen: registry.sessions[agentId]?.first_seen || now,\n      last_activity: now,\n      tool_name: toolName,\n      file_path: filePath,\n      working_directory: process.cwd(),\n      hook_event: input.hook_event_name || 'PostToolUse'\n    };\n    \n    registry.sessions[agentId] = sessionData;\n    \n    // Write registry back\n    const success = writeRegistry(registry);\n    \n    if (success && CONFIG.logAllActivity) {\n      logSessionActivity(agentId, toolName, filePath, 'registry_updated');\n    }\n    \n    return success;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction logSessionActivity(agentId, toolName, filePath, action) {\n  try {\n    const activityDir = path.join(process.cwd(), CONFIG.activityDirectory);\n    const logFile = path.join(activityDir, 'registry-activity.jsonl');\n    \n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      session_id: agentId,\n      pid: process.pid,\n      parent_pid: process.ppid,\n      action: action,\n      tool_name: toolName,\n      file_path: filePath,\n      working_directory: process.cwd()\n    };\n    \n    fs.appendFileSync(logFile, JSON.stringify(logEntry) + '\\n');\n  } catch (error) {\n    // Silent failure - don't block operations\n  }\n}\n\n// Parse input from stdin\nfunction parseInput() {\n  return new Promise((resolve, reject) => {\n    let input = '';\n    \n    process.stdin.on('data', (chunk) => {\n      input += chunk.toString();\n    });\n    \n    process.stdin.on('end', () => {\n      try {\n        const data = JSON.parse(input);\n        resolve(data);\n      } catch (error) {\n        reject(new Error(`Invalid JSON input: ${error.message}`));\n      }\n    });\n    \n    process.stdin.on('error', reject);\n  });\n}\n\n// Main execution function\nasync function main() {\n  try {\n    // Parse input from Claude Code\n    const input = await parseInput();\n    const { tool_name, tool_input, session_id } = input;\n    \n    // Only handle file modification tools\n    if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\n      process.exit(0);\n    }\n\n    const filePath = extractFilePath(tool_input);\n    if (!filePath) {\n      process.exit(0);\n    }\n\n    // Update agent registry\n    const success = updateAgentRegistry(input, tool_name, filePath);\n    \n    if (success) {\n      console.log(`Agent session registered: ${extractAgentId(input)}`);\n    } else {\n      console.log(`Agent registry update skipped (concurrent access)`);\n    }\n    \n    process.exit(0);\n\n  } catch (error) {\n    console.error(`Agent registry failed: ${error.message}`);\n    process.exit(1);\n  }\n}\n\n// Execute if called directly\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = { main, parseInput, extractAgentId, updateAgentRegistry };","structuredPatch":[{"oldStart":237,"oldLines":7,"newStart":237,"newLines":7,"lines":["   try {","     // Parse input from Claude Code","     const input = await parseInput();","-    const { tool_name, tool_input, session_id } = input;","+    const { tool_name, tool_input } = input;","     ","     // Only handle file modification tools","     if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {"]}],"userModified":false,"replaceAll":false}},"process_pid":160818,"parent_pid":160817,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:21:18.466Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/lock-utils.js\",\"old_string\":\"      .replace(/[\\\\/\\\\\\\\]/g, '-') // Replace slashes with dashes\",\"new_string\":\"      .replace(/[/\\\\\\\\]/g, '-') // Replace slashes with dashes\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/lock-utils.js\",\"oldString\":\"      .replace(/[\\\\/\\\\\\\\]/g, '-') // Replace slashes with dashes\",\"newString\":\"      .replace(/[/\\\\\\\\]/g, '-') // Replace slashes with dashes\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst fs = require('fs');\\nconst path = require('path');\\nconst crypto = require('crypto');\\n\\nclass LockUtils {\\n  constructor(lockDir = '.agent-locks', activityDir = '.agent-activity') {\\n    this.lockDir = path.resolve(lockDir);\\n    this.activityDir = path.resolve(activityDir);\\n    this.defaultTimeout = 10 * 60 * 1000; // 10 minutes\\n    \\n    // Ensure directories exist\\n    this.ensureDirectories();\\n  }\\n\\n  ensureDirectories() {\\n    try {\\n      if (!fs.existsSync(this.lockDir)) {\\n        fs.mkdirSync(this.lockDir, { recursive: true });\\n      }\\n      if (!fs.existsSync(this.activityDir)) {\\n        fs.mkdirSync(this.activityDir, { recursive: true });\\n      }\\n    } catch (error) {\\n      console.warn(`Warning: Could not create lock directories: ${error.message}`);\\n    }\\n  }\\n\\n  /**\\n   * Convert file path to lock file name\\n   * @param {string} filePath - Original file path\\n   * @returns {string} Lock file name\\n   */\\n  pathToLockName(filePath) {\\n    // Convert path separators to dashes and remove leading slashes/dots\\n    return filePath\\n      .replace(/^\\\\.?\\\\/+/, '') // Remove leading ./ or /\\n      .replace(/[\\\\/\\\\\\\\]/g, '-') // Replace slashes with dashes\\n      .replace(/[<>:\\\"|?*]/g, '_') // Replace invalid filename chars\\n      + '.lock';\\n  }\\n\\n  /**\\n   * Get full path to lock file\\n   * @param {string} filePath - Original file path\\n   * @returns {string} Full lock file path\\n   */\\n  getLockFilePath(filePath) {\\n    const lockName = this.pathToLockName(filePath);\\n    return path.join(this.lockDir, lockName);\\n  }\\n\\n  /**\\n   * Check if file is currently locked\\n   * @param {string} filePath - File to check\\n   * @returns {Object|null} Lock info or null if not locked\\n   */\\n  isLocked(filePath) {\\n    const lockFilePath = this.getLockFilePath(filePath);\\n    \\n    try {\\n      if (!fs.existsSync(lockFilePath)) {\\n        return null;\\n      }\\n\\n      const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\\n      \\n      // Check if lock has expired\\n      const now = new Date();\\n      const expiresAt = new Date(lockData.expires_at);\\n      \\n      if (now > expiresAt) {\\n        // Lock expired, remove it\\n        this.releaseLock(filePath);\\n        return null;\\n      }\\n\\n      return lockData;\\n    } catch (error) {\\n      console.warn(`Warning: Error checking lock for ${filePath}: ${error.message}`);\\n      return null;\\n    }\\n  }\\n\\n  /**\\n   * Create a lock for the specified file\\n   * @param {string} filePath - File to lock\\n   * @param {string} agentId - Agent creating the lock\\n   * @param {string} operation - Operation type (editing, writing, etc)\\n   * @param {string} sessionId - Session ID\\n   * @param {number} timeout - Lock timeout in milliseconds\\n   * @returns {boolean} True if lock created successfully\\n   */\\n  createLock(filePath, agentId, operation = 'editing', sessionId = 'unknown', timeout = null) {\\n    const lockFilePath = this.getLockFilePath(filePath);\\n    timeout = timeout || this.defaultTimeout;\\n    \\n    try {\\n      // Check if already locked\\n      const existingLock = this.isLocked(filePath);\\n      if (existingLock && existingLock.agent_id !== agentId) {\\n        return false; // Already locked by different agent\\n      }\\n\\n      const now = new Date();\\n      const expiresAt = new Date(now.getTime() + timeout);\\n      \\n      const lockData = {\\n        agent_id: agentId,\\n        file_path: filePath,\\n        locked_at: now.toISOString(),\\n        operation: operation,\\n        session_id: sessionId,\\n        expires_at: expiresAt.toISOString(),\\n        lock_id: crypto.randomUUID()\\n      };\\n\\n      // Atomic write using temporary file\\n      const tempPath = lockFilePath + '.tmp';\\n      fs.writeFileSync(tempPath, JSON.stringify(lockData, null, 2));\\n      fs.renameSync(tempPath, lockFilePath);\\n\\n      this.logActivity('lock_created', agentId, filePath, { operation, session_id: sessionId });\\n      return true;\\n    } catch (error) {\\n      console.warn(`Warning: Could not create lock for ${filePath}: ${error.message}`);\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * Release a lock for the specified file\\n   * @param {string} filePath - File to unlock\\n   * @param {string} agentId - Agent releasing the lock (optional, for verification)\\n   * @returns {boolean} True if lock released successfully\\n   */\\n  releaseLock(filePath, agentId = null) {\\n    const lockFilePath = this.getLockFilePath(filePath);\\n    \\n    try {\\n      if (!fs.existsSync(lockFilePath)) {\\n        return true; // Already unlocked\\n      }\\n\\n      // If agentId provided, verify ownership\\n      if (agentId) {\\n        const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\\n        if (lockData.agent_id !== agentId) {\\n          console.warn(`Warning: Agent ${agentId} tried to release lock owned by ${lockData.agent_id}`);\\n          return false;\\n        }\\n      }\\n\\n      fs.unlinkSync(lockFilePath);\\n      this.logActivity('lock_released', agentId, filePath, {});\\n      return true;\\n    } catch (error) {\\n      console.warn(`Warning: Could not release lock for ${filePath}: ${error.message}`);\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * Release all locks held by a specific agent\\n   * @param {string} agentId - Agent whose locks to release\\n   * @returns {number} Number of locks released\\n   */\\n  releaseAllLocks(agentId) {\\n    let released = 0;\\n    \\n    try {\\n      const lockFiles = fs.readdirSync(this.lockDir);\\n      \\n      for (const lockFile of lockFiles) {\\n        if (!lockFile.endsWith('.lock')) continue;\\n        \\n        const lockFilePath = path.join(this.lockDir, lockFile);\\n        try {\\n          const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\\n          if (lockData.agent_id === agentId) {\\n            fs.unlinkSync(lockFilePath);\\n            this.logActivity('lock_released', agentId, lockData.file_path, { reason: 'agent_cleanup' });\\n            released++;\\n          }\\n        } catch (error) {\\n          console.warn(`Warning: Error processing lock file ${lockFile}: ${error.message}`);\\n        }\\n      }\\n    } catch (error) {\\n      console.warn(`Warning: Error releasing locks for agent ${agentId}: ${error.message}`);\\n    }\\n\\n    return released;\\n  }\\n\\n  /**\\n   * Get all current locks\\n   * @returns {Array} Array of lock objects\\n   */\\n  getAllLocks() {\\n    const locks = [];\\n    \\n    try {\\n      const lockFiles = fs.readdirSync(this.lockDir);\\n      \\n      for (const lockFile of lockFiles) {\\n        if (!lockFile.endsWith('.lock')) continue;\\n        \\n        const lockFilePath = path.join(this.lockDir, lockFile);\\n        try {\\n          const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\\n          \\n          // Check if expired\\n          const now = new Date();\\n          const expiresAt = new Date(lockData.expires_at);\\n          \\n          if (now > expiresAt) {\\n            // Clean up expired lock\\n            fs.unlinkSync(lockFilePath);\\n            continue;\\n          }\\n          \\n          locks.push(lockData);\\n        } catch (error) {\\n          console.warn(`Warning: Error reading lock file ${lockFile}: ${error.message}`);\\n        }\\n      }\\n    } catch (error) {\\n      console.warn(`Warning: Error getting all locks: ${error.message}`);\\n    }\\n\\n    return locks;\\n  }\\n\\n  /**\\n   * Log activity to the activity feed\\n   * @param {string} action - Action type\\n   * @param {string} agentId - Agent ID\\n   * @param {string} filePath - File path\\n   * @param {Object} details - Additional details\\n   */\\n  logActivity(action, agentId, filePath, details = {}) {\\n    try {\\n      const activityFile = path.join(this.activityDir, 'live-feed.jsonl');\\n      const entry = {\\n        timestamp: new Date().toISOString(),\\n        action: action,\\n        agent_id: agentId,\\n        file_path: filePath,\\n        ...details\\n      };\\n      \\n      fs.appendFileSync(activityFile, JSON.stringify(entry) + '\\\\n');\\n    } catch (error) {\\n      console.warn(`Warning: Could not log activity: ${error.message}`);\\n    }\\n  }\\n\\n  /**\\n   * Clean up expired locks\\n   * @returns {number} Number of locks cleaned up\\n   */\\n  cleanupExpiredLocks() {\\n    let cleaned = 0;\\n    \\n    try {\\n      const lockFiles = fs.readdirSync(this.lockDir);\\n      const now = new Date();\\n      \\n      for (const lockFile of lockFiles) {\\n        if (!lockFile.endsWith('.lock')) continue;\\n        \\n        const lockFilePath = path.join(this.lockDir, lockFile);\\n        try {\\n          const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\\n          const expiresAt = new Date(lockData.expires_at);\\n          \\n          if (now > expiresAt) {\\n            fs.unlinkSync(lockFilePath);\\n            this.logActivity('lock_expired', lockData.agent_id, lockData.file_path, {});\\n            cleaned++;\\n          }\\n        } catch (error) {\\n          console.warn(`Warning: Error processing lock file ${lockFile}: ${error.message}`);\\n        }\\n      }\\n    } catch (error) {\\n      console.warn(`Warning: Error cleaning up expired locks: ${error.message}`);\\n    }\\n\\n    return cleaned;\\n  }\\n}\\n\\nmodule.exports = LockUtils;\",\"structuredPatch\":[{\"oldStart\":36,\"oldLines\":7,\"newStart\":36,\"newLines\":7,\"lines\":[\"     // Convert path separators to dashes and remove leading slashes/dots\",\"     return filePath\",\"       .replace(/^\\\\.?\\\\/+/, '') // Remove leading ./ or /\",\"-      .replace(/[\\\\/\\\\\\\\]/g, '-') // Replace slashes with dashes\",\"+      .replace(/[/\\\\\\\\]/g, '-') // Replace slashes with dashes\",\"       .replace(/[<>:\\\"|?*]/g, '_') // Replace invalid filename chars\",\"       + '.lock';\",\"   }\"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/lock-utils.js","old_string":"      .replace(/[\\/\\\\]/g, '-') // Replace slashes with dashes","new_string":"      .replace(/[/\\\\]/g, '-') // Replace slashes with dashes"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/lock-utils.js","oldString":"      .replace(/[\\/\\\\]/g, '-') // Replace slashes with dashes","newString":"      .replace(/[/\\\\]/g, '-') // Replace slashes with dashes","originalFile":"#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\nclass LockUtils {\n  constructor(lockDir = '.agent-locks', activityDir = '.agent-activity') {\n    this.lockDir = path.resolve(lockDir);\n    this.activityDir = path.resolve(activityDir);\n    this.defaultTimeout = 10 * 60 * 1000; // 10 minutes\n    \n    // Ensure directories exist\n    this.ensureDirectories();\n  }\n\n  ensureDirectories() {\n    try {\n      if (!fs.existsSync(this.lockDir)) {\n        fs.mkdirSync(this.lockDir, { recursive: true });\n      }\n      if (!fs.existsSync(this.activityDir)) {\n        fs.mkdirSync(this.activityDir, { recursive: true });\n      }\n    } catch (error) {\n      console.warn(`Warning: Could not create lock directories: ${error.message}`);\n    }\n  }\n\n  /**\n   * Convert file path to lock file name\n   * @param {string} filePath - Original file path\n   * @returns {string} Lock file name\n   */\n  pathToLockName(filePath) {\n    // Convert path separators to dashes and remove leading slashes/dots\n    return filePath\n      .replace(/^\\.?\\/+/, '') // Remove leading ./ or /\n      .replace(/[\\/\\\\]/g, '-') // Replace slashes with dashes\n      .replace(/[<>:\"|?*]/g, '_') // Replace invalid filename chars\n      + '.lock';\n  }\n\n  /**\n   * Get full path to lock file\n   * @param {string} filePath - Original file path\n   * @returns {string} Full lock file path\n   */\n  getLockFilePath(filePath) {\n    const lockName = this.pathToLockName(filePath);\n    return path.join(this.lockDir, lockName);\n  }\n\n  /**\n   * Check if file is currently locked\n   * @param {string} filePath - File to check\n   * @returns {Object|null} Lock info or null if not locked\n   */\n  isLocked(filePath) {\n    const lockFilePath = this.getLockFilePath(filePath);\n    \n    try {\n      if (!fs.existsSync(lockFilePath)) {\n        return null;\n      }\n\n      const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\n      \n      // Check if lock has expired\n      const now = new Date();\n      const expiresAt = new Date(lockData.expires_at);\n      \n      if (now > expiresAt) {\n        // Lock expired, remove it\n        this.releaseLock(filePath);\n        return null;\n      }\n\n      return lockData;\n    } catch (error) {\n      console.warn(`Warning: Error checking lock for ${filePath}: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Create a lock for the specified file\n   * @param {string} filePath - File to lock\n   * @param {string} agentId - Agent creating the lock\n   * @param {string} operation - Operation type (editing, writing, etc)\n   * @param {string} sessionId - Session ID\n   * @param {number} timeout - Lock timeout in milliseconds\n   * @returns {boolean} True if lock created successfully\n   */\n  createLock(filePath, agentId, operation = 'editing', sessionId = 'unknown', timeout = null) {\n    const lockFilePath = this.getLockFilePath(filePath);\n    timeout = timeout || this.defaultTimeout;\n    \n    try {\n      // Check if already locked\n      const existingLock = this.isLocked(filePath);\n      if (existingLock && existingLock.agent_id !== agentId) {\n        return false; // Already locked by different agent\n      }\n\n      const now = new Date();\n      const expiresAt = new Date(now.getTime() + timeout);\n      \n      const lockData = {\n        agent_id: agentId,\n        file_path: filePath,\n        locked_at: now.toISOString(),\n        operation: operation,\n        session_id: sessionId,\n        expires_at: expiresAt.toISOString(),\n        lock_id: crypto.randomUUID()\n      };\n\n      // Atomic write using temporary file\n      const tempPath = lockFilePath + '.tmp';\n      fs.writeFileSync(tempPath, JSON.stringify(lockData, null, 2));\n      fs.renameSync(tempPath, lockFilePath);\n\n      this.logActivity('lock_created', agentId, filePath, { operation, session_id: sessionId });\n      return true;\n    } catch (error) {\n      console.warn(`Warning: Could not create lock for ${filePath}: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Release a lock for the specified file\n   * @param {string} filePath - File to unlock\n   * @param {string} agentId - Agent releasing the lock (optional, for verification)\n   * @returns {boolean} True if lock released successfully\n   */\n  releaseLock(filePath, agentId = null) {\n    const lockFilePath = this.getLockFilePath(filePath);\n    \n    try {\n      if (!fs.existsSync(lockFilePath)) {\n        return true; // Already unlocked\n      }\n\n      // If agentId provided, verify ownership\n      if (agentId) {\n        const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\n        if (lockData.agent_id !== agentId) {\n          console.warn(`Warning: Agent ${agentId} tried to release lock owned by ${lockData.agent_id}`);\n          return false;\n        }\n      }\n\n      fs.unlinkSync(lockFilePath);\n      this.logActivity('lock_released', agentId, filePath, {});\n      return true;\n    } catch (error) {\n      console.warn(`Warning: Could not release lock for ${filePath}: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Release all locks held by a specific agent\n   * @param {string} agentId - Agent whose locks to release\n   * @returns {number} Number of locks released\n   */\n  releaseAllLocks(agentId) {\n    let released = 0;\n    \n    try {\n      const lockFiles = fs.readdirSync(this.lockDir);\n      \n      for (const lockFile of lockFiles) {\n        if (!lockFile.endsWith('.lock')) continue;\n        \n        const lockFilePath = path.join(this.lockDir, lockFile);\n        try {\n          const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\n          if (lockData.agent_id === agentId) {\n            fs.unlinkSync(lockFilePath);\n            this.logActivity('lock_released', agentId, lockData.file_path, { reason: 'agent_cleanup' });\n            released++;\n          }\n        } catch (error) {\n          console.warn(`Warning: Error processing lock file ${lockFile}: ${error.message}`);\n        }\n      }\n    } catch (error) {\n      console.warn(`Warning: Error releasing locks for agent ${agentId}: ${error.message}`);\n    }\n\n    return released;\n  }\n\n  /**\n   * Get all current locks\n   * @returns {Array} Array of lock objects\n   */\n  getAllLocks() {\n    const locks = [];\n    \n    try {\n      const lockFiles = fs.readdirSync(this.lockDir);\n      \n      for (const lockFile of lockFiles) {\n        if (!lockFile.endsWith('.lock')) continue;\n        \n        const lockFilePath = path.join(this.lockDir, lockFile);\n        try {\n          const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\n          \n          // Check if expired\n          const now = new Date();\n          const expiresAt = new Date(lockData.expires_at);\n          \n          if (now > expiresAt) {\n            // Clean up expired lock\n            fs.unlinkSync(lockFilePath);\n            continue;\n          }\n          \n          locks.push(lockData);\n        } catch (error) {\n          console.warn(`Warning: Error reading lock file ${lockFile}: ${error.message}`);\n        }\n      }\n    } catch (error) {\n      console.warn(`Warning: Error getting all locks: ${error.message}`);\n    }\n\n    return locks;\n  }\n\n  /**\n   * Log activity to the activity feed\n   * @param {string} action - Action type\n   * @param {string} agentId - Agent ID\n   * @param {string} filePath - File path\n   * @param {Object} details - Additional details\n   */\n  logActivity(action, agentId, filePath, details = {}) {\n    try {\n      const activityFile = path.join(this.activityDir, 'live-feed.jsonl');\n      const entry = {\n        timestamp: new Date().toISOString(),\n        action: action,\n        agent_id: agentId,\n        file_path: filePath,\n        ...details\n      };\n      \n      fs.appendFileSync(activityFile, JSON.stringify(entry) + '\\n');\n    } catch (error) {\n      console.warn(`Warning: Could not log activity: ${error.message}`);\n    }\n  }\n\n  /**\n   * Clean up expired locks\n   * @returns {number} Number of locks cleaned up\n   */\n  cleanupExpiredLocks() {\n    let cleaned = 0;\n    \n    try {\n      const lockFiles = fs.readdirSync(this.lockDir);\n      const now = new Date();\n      \n      for (const lockFile of lockFiles) {\n        if (!lockFile.endsWith('.lock')) continue;\n        \n        const lockFilePath = path.join(this.lockDir, lockFile);\n        try {\n          const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\n          const expiresAt = new Date(lockData.expires_at);\n          \n          if (now > expiresAt) {\n            fs.unlinkSync(lockFilePath);\n            this.logActivity('lock_expired', lockData.agent_id, lockData.file_path, {});\n            cleaned++;\n          }\n        } catch (error) {\n          console.warn(`Warning: Error processing lock file ${lockFile}: ${error.message}`);\n        }\n      }\n    } catch (error) {\n      console.warn(`Warning: Error cleaning up expired locks: ${error.message}`);\n    }\n\n    return cleaned;\n  }\n}\n\nmodule.exports = LockUtils;","structuredPatch":[{"oldStart":36,"oldLines":7,"newStart":36,"newLines":7,"lines":["     // Convert path separators to dashes and remove leading slashes/dots","     return filePath","       .replace(/^\\.?\\/+/, '') // Remove leading ./ or /","-      .replace(/[\\/\\\\]/g, '-') // Replace slashes with dashes","+      .replace(/[/\\\\]/g, '-') // Replace slashes with dashes","       .replace(/[<>:\"|?*]/g, '_') // Replace invalid filename chars","       + '.lock';","   }"]}],"userModified":false,"replaceAll":false}},"process_pid":160904,"parent_pid":160903,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:21:29.213Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/index.js\",\"old_string\":\"    .replace(/[\\\\/\\\\\\\\]/g, '-')\",\"new_string\":\"    .replace(/[/\\\\\\\\]/g, '-')\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/index.js\",\"oldString\":\"    .replace(/[\\\\/\\\\\\\\]/g, '-')\",\"newString\":\"    .replace(/[/\\\\\\\\]/g, '-')\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst fs = require('fs');\\nconst path = require('path');\\nconst crypto = require('crypto');\\n\\n/**\\n * File Locking Hook for Claude Code - Compliant with Anthropic Documentation\\n * \\n * This is a PreToolUse hook that blocks Edit/Write/MultiEdit operations\\n * when files are locked by other agents.\\n */\\n\\n// Configuration\\nconst CONFIG = {\\n  lockTimeout: 600, // 10 minutes in seconds\\n  lockDirectory: '.agent-locks',\\n  activityDirectory: '.agent-activity',\\n  excludePatterns: [\\n    /\\\\.log$/,\\n    /\\\\.tmp$/,\\n    /\\\\.temp$/,\\n    /\\\\.lock$/,\\n    /\\\\.env/,\\n    /\\\\.git\\\\//,\\n    /\\\\.agent-/,\\n    /node_modules\\\\//,\\n    /\\\\.pyc$/,\\n    /__pycache__\\\\//\\n  ]\\n};\\n\\n// Utility functions\\nfunction ensureDirectories() {\\n  const lockDir = path.join(process.cwd(), CONFIG.lockDirectory);\\n  const activityDir = path.join(process.cwd(), CONFIG.activityDirectory);\\n  \\n  try {\\n    if (!fs.existsSync(lockDir)) {\\n      fs.mkdirSync(lockDir, { recursive: true });\\n    }\\n    if (!fs.existsSync(activityDir)) {\\n      fs.mkdirSync(activityDir, { recursive: true });\\n    }\\n  } catch (error) {\\n    // Silent failure - don't block operations if directories can't be created\\n  }\\n}\\n\\nfunction pathToLockName(filePath) {\\n  return filePath\\n    .replace(/^\\\\.?\\\\/+/, '')\\n    .replace(/[\\\\/\\\\\\\\]/g, '-')\\n    .replace(/[<>:\\\"|?*]/g, '_')\\n    + '.lock';\\n}\\n\\nfunction getLockFilePath(filePath) {\\n  const lockName = pathToLockName(filePath);\\n  const lockDir = path.join(process.cwd(), CONFIG.lockDirectory);\\n  return path.join(lockDir, lockName);\\n}\\n\\nfunction isLocked(filePath) {\\n  const lockFilePath = getLockFilePath(filePath);\\n  \\n  try {\\n    if (!fs.existsSync(lockFilePath)) {\\n      return null;\\n    }\\n\\n    const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\\n    \\n    // Check if lock has expired\\n    const now = new Date();\\n    const expiresAt = new Date(lockData.expires_at);\\n    \\n    if (now > expiresAt) {\\n      // Lock expired, remove it\\n      try {\\n        fs.unlinkSync(lockFilePath);\\n      } catch (error) {\\n        // Silent failure\\n      }\\n      return null;\\n    }\\n\\n    return lockData;\\n  } catch (error) {\\n    return null;\\n  }\\n}\\n\\nfunction createLock(filePath, agentId, operation, sessionId) {\\n  const lockFilePath = getLockFilePath(filePath);\\n  \\n  try {\\n    // Check if already locked\\n    const existingLock = isLocked(filePath);\\n    if (existingLock && existingLock.agent_id !== agentId) {\\n      return false;\\n    }\\n\\n    const now = new Date();\\n    const expiresAt = new Date(now.getTime() + (CONFIG.lockTimeout * 1000));\\n    \\n    const lockData = {\\n      agent_id: agentId,\\n      file_path: filePath,\\n      locked_at: now.toISOString(),\\n      operation: operation,\\n      session_id: sessionId,\\n      expires_at: expiresAt.toISOString(),\\n      lock_id: crypto.randomUUID()\\n    };\\n\\n    // Atomic write\\n    const tempPath = lockFilePath + '.tmp';\\n    fs.writeFileSync(tempPath, JSON.stringify(lockData, null, 2));\\n    fs.renameSync(tempPath, lockFilePath);\\n\\n    logActivity('lock_created', agentId, filePath, { operation, session_id: sessionId });\\n    return true;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\n\\nfunction logActivity(action, agentId, filePath, details = {}) {\\n  try {\\n    const activityDir = path.join(process.cwd(), CONFIG.activityDirectory);\\n    const activityFile = path.join(activityDir, 'live-feed.jsonl');\\n    const entry = {\\n      timestamp: new Date().toISOString(),\\n      action: action,\\n      agent_id: agentId,\\n      file_path: filePath,\\n      ...details\\n    };\\n    \\n    fs.appendFileSync(activityFile, JSON.stringify(entry) + '\\\\n');\\n  } catch (error) {\\n    // Silent failure - don't block operations if logging fails\\n  }\\n}\\n\\nfunction extractFilePath(toolInput) {\\n  return toolInput.file_path || \\n         toolInput.filePath ||\\n         (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\\n         null;\\n}\\n\\nfunction extractAgentId(input) {\\n  // Use stable session ID from Claude Code\\n  return input.session_id || `session-${process.ppid}`;\\n}\\n\\nfunction detectHookPhase(input) {\\n  // Direct detection from Claude Code hook event name!\\n  return input.hook_event_name || 'PreToolUse';\\n}\\n\\nfunction releaseLock(filePath, agentId) {\\n  try {\\n    const lockFilePath = getLockFilePath(filePath);\\n    const existingLock = isLocked(filePath);\\n    \\n    // Only release if we own the lock\\n    if (existingLock && existingLock.agent_id === agentId) {\\n      fs.unlinkSync(lockFilePath);\\n      logActivity('lock_released', agentId, filePath, { operation: 'completed' });\\n      return true;\\n    }\\n    \\n    return false;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\n\\nfunction shouldExcludeFile(filePath) {\\n  return CONFIG.excludePatterns.some(pattern => pattern.test(filePath));\\n}\\n\\nfunction cleanupExpiredLocks() {\\n  try {\\n    const lockDir = path.join(process.cwd(), CONFIG.lockDirectory);\\n    if (!fs.existsSync(lockDir)) return;\\n    \\n    const lockFiles = fs.readdirSync(lockDir);\\n    const now = new Date();\\n    \\n    for (const lockFile of lockFiles) {\\n      if (!lockFile.endsWith('.lock')) continue;\\n      \\n      const lockFilePath = path.join(lockDir, lockFile);\\n      try {\\n        const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\\n        const expiresAt = new Date(lockData.expires_at);\\n        \\n        if (now > expiresAt) {\\n          fs.unlinkSync(lockFilePath);\\n          logActivity('lock_expired', lockData.agent_id, lockData.file_path, {});\\n        }\\n      } catch (error) {\\n        // Silent failure\\n      }\\n    }\\n  } catch (error) {\\n    // Silent failure\\n  }\\n}\\n\\n// Parse input from stdin\\nfunction parseInput() {\\n  return new Promise((resolve, reject) => {\\n    let input = '';\\n    \\n    process.stdin.on('data', (chunk) => {\\n      input += chunk.toString();\\n    });\\n    \\n    process.stdin.on('end', () => {\\n      try {\\n        const data = JSON.parse(input);\\n        resolve(data);\\n      } catch (error) {\\n        reject(new Error(`Invalid JSON input: ${error.message}`));\\n      }\\n    });\\n    \\n    process.stdin.on('error', reject);\\n  });\\n}\\n\\n// Main execution function\\nasync function main() {\\n  try {\\n    // Parse input from Claude Code\\n    const input = await parseInput();\\n    const { tool_name, tool_input, session_id } = input;\\n    \\n    // DEBUG: Log everything available for agent identification\\n    console.error('=== AGENT ID DEBUG ===');\\n    console.error('Input keys:', Object.keys(input));\\n    console.error('Full input:', JSON.stringify(input, null, 2));\\n    console.error('Process env keys:', Object.keys(process.env).filter(k => k.includes('CLAUDE') || k.includes('SESSION') || k.includes('AGENT')));\\n    console.error('process.pid:', process.pid);\\n    console.error('process.ppid:', process.ppid);\\n    console.error('process.argv:', process.argv);\\n    console.error('======================');\\n    \\n    // Only handle file modification tools\\n    if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\\n      // Exit with code 0 (success) - allow operation\\n      process.exit(0);\\n    }\\n\\n    const filePath = extractFilePath(tool_input);\\n    if (!filePath) {\\n      // No file path, allow operation\\n      process.exit(0);\\n    }\\n\\n    // Check if file should be excluded from locking\\n    if (shouldExcludeFile(filePath)) {\\n      // Excluded file, allow operation\\n      process.exit(0);\\n    }\\n\\n    // Ensure directories exist\\n    ensureDirectories();\\n\\n    const agentId = extractAgentId(input);\\n    const operation = tool_name.toLowerCase();\\n\\n    // Clean up any expired locks first\\n    cleanupExpiredLocks();\\n\\n    // Direct phase detection from Claude Code hook event name\\n    const hookPhase = detectHookPhase(input);\\n    \\n    if (hookPhase === 'PostToolUse') {\\n      // PostToolUse: Release lock and allow\\n      const released = releaseLock(filePath, agentId);\\n      console.log(released ? `Lock released for \\\"${filePath}\\\"` : `No lock to release for \\\"${filePath}\\\"`);\\n      process.exit(0);\\n    }\\n\\n    // PreToolUse: Check locks and potentially block\\n    const existingLock = isLocked(filePath);\\n    \\n    if (existingLock) {\\n      if (existingLock.agent_id === agentId) {\\n        // Same agent already has the lock, allow operation\\n        console.log(`File already locked by this agent: ${filePath}`);\\n        process.exit(0);\\n      } else {\\n        // File locked by different agent, BLOCK operation\\n        const timeRemaining = Math.ceil((new Date(existingLock.expires_at) - new Date()) / 1000 / 60);\\n        const errorMessage = `File \\\"${filePath}\\\" is currently being ${existingLock.operation} by agent \\\"${existingLock.agent_id}\\\". Lock expires in ${timeRemaining} minutes. Please wait or work on a different file.`;\\n        \\n        // Output error to stderr and exit with code 2 (blocking)\\n        console.error(errorMessage);\\n        process.exit(2);\\n      }\\n    }\\n\\n    // File is not locked, create lock and allow operation\\n    const lockCreated = createLock(filePath, agentId, operation, session_id);\\n    \\n    if (lockCreated) {\\n      console.log(`File lock acquired for \\\"${filePath}\\\"`);\\n      process.exit(0);\\n    } else {\\n      // Lock creation failed, allow operation with warning\\n      console.log(`Warning: Could not create file lock for \\\"${filePath}\\\", proceeding without lock protection`);\\n      process.exit(0);\\n    }\\n\\n  } catch (error) {\\n    // Log error but don't block operation (exit code 1 = non-blocking error)\\n    console.error(`File lock check failed: ${error.message}`);\\n    process.exit(1);\\n  }\\n}\\n\\n// Execute if called directly\\nif (require.main === module) {\\n  main();\\n}\",\"structuredPatch\":[{\"oldStart\":50,\"oldLines\":7,\"newStart\":50,\"newLines\":7,\"lines\":[\" function pathToLockName(filePath) {\",\"   return filePath\",\"     .replace(/^\\\\.?\\\\/+/, '')\",\"-    .replace(/[\\\\/\\\\\\\\]/g, '-')\",\"+    .replace(/[/\\\\\\\\]/g, '-')\",\"     .replace(/[<>:\\\"|?*]/g, '_')\",\"     + '.lock';\",\" }\"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/index.js","old_string":"    .replace(/[\\/\\\\]/g, '-')","new_string":"    .replace(/[/\\\\]/g, '-')"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/index.js","oldString":"    .replace(/[\\/\\\\]/g, '-')","newString":"    .replace(/[/\\\\]/g, '-')","originalFile":"#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\n\n/**\n * File Locking Hook for Claude Code - Compliant with Anthropic Documentation\n * \n * This is a PreToolUse hook that blocks Edit/Write/MultiEdit operations\n * when files are locked by other agents.\n */\n\n// Configuration\nconst CONFIG = {\n  lockTimeout: 600, // 10 minutes in seconds\n  lockDirectory: '.agent-locks',\n  activityDirectory: '.agent-activity',\n  excludePatterns: [\n    /\\.log$/,\n    /\\.tmp$/,\n    /\\.temp$/,\n    /\\.lock$/,\n    /\\.env/,\n    /\\.git\\//,\n    /\\.agent-/,\n    /node_modules\\//,\n    /\\.pyc$/,\n    /__pycache__\\//\n  ]\n};\n\n// Utility functions\nfunction ensureDirectories() {\n  const lockDir = path.join(process.cwd(), CONFIG.lockDirectory);\n  const activityDir = path.join(process.cwd(), CONFIG.activityDirectory);\n  \n  try {\n    if (!fs.existsSync(lockDir)) {\n      fs.mkdirSync(lockDir, { recursive: true });\n    }\n    if (!fs.existsSync(activityDir)) {\n      fs.mkdirSync(activityDir, { recursive: true });\n    }\n  } catch (error) {\n    // Silent failure - don't block operations if directories can't be created\n  }\n}\n\nfunction pathToLockName(filePath) {\n  return filePath\n    .replace(/^\\.?\\/+/, '')\n    .replace(/[\\/\\\\]/g, '-')\n    .replace(/[<>:\"|?*]/g, '_')\n    + '.lock';\n}\n\nfunction getLockFilePath(filePath) {\n  const lockName = pathToLockName(filePath);\n  const lockDir = path.join(process.cwd(), CONFIG.lockDirectory);\n  return path.join(lockDir, lockName);\n}\n\nfunction isLocked(filePath) {\n  const lockFilePath = getLockFilePath(filePath);\n  \n  try {\n    if (!fs.existsSync(lockFilePath)) {\n      return null;\n    }\n\n    const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\n    \n    // Check if lock has expired\n    const now = new Date();\n    const expiresAt = new Date(lockData.expires_at);\n    \n    if (now > expiresAt) {\n      // Lock expired, remove it\n      try {\n        fs.unlinkSync(lockFilePath);\n      } catch (error) {\n        // Silent failure\n      }\n      return null;\n    }\n\n    return lockData;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction createLock(filePath, agentId, operation, sessionId) {\n  const lockFilePath = getLockFilePath(filePath);\n  \n  try {\n    // Check if already locked\n    const existingLock = isLocked(filePath);\n    if (existingLock && existingLock.agent_id !== agentId) {\n      return false;\n    }\n\n    const now = new Date();\n    const expiresAt = new Date(now.getTime() + (CONFIG.lockTimeout * 1000));\n    \n    const lockData = {\n      agent_id: agentId,\n      file_path: filePath,\n      locked_at: now.toISOString(),\n      operation: operation,\n      session_id: sessionId,\n      expires_at: expiresAt.toISOString(),\n      lock_id: crypto.randomUUID()\n    };\n\n    // Atomic write\n    const tempPath = lockFilePath + '.tmp';\n    fs.writeFileSync(tempPath, JSON.stringify(lockData, null, 2));\n    fs.renameSync(tempPath, lockFilePath);\n\n    logActivity('lock_created', agentId, filePath, { operation, session_id: sessionId });\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction logActivity(action, agentId, filePath, details = {}) {\n  try {\n    const activityDir = path.join(process.cwd(), CONFIG.activityDirectory);\n    const activityFile = path.join(activityDir, 'live-feed.jsonl');\n    const entry = {\n      timestamp: new Date().toISOString(),\n      action: action,\n      agent_id: agentId,\n      file_path: filePath,\n      ...details\n    };\n    \n    fs.appendFileSync(activityFile, JSON.stringify(entry) + '\\n');\n  } catch (error) {\n    // Silent failure - don't block operations if logging fails\n  }\n}\n\nfunction extractFilePath(toolInput) {\n  return toolInput.file_path || \n         toolInput.filePath ||\n         (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\n         null;\n}\n\nfunction extractAgentId(input) {\n  // Use stable session ID from Claude Code\n  return input.session_id || `session-${process.ppid}`;\n}\n\nfunction detectHookPhase(input) {\n  // Direct detection from Claude Code hook event name!\n  return input.hook_event_name || 'PreToolUse';\n}\n\nfunction releaseLock(filePath, agentId) {\n  try {\n    const lockFilePath = getLockFilePath(filePath);\n    const existingLock = isLocked(filePath);\n    \n    // Only release if we own the lock\n    if (existingLock && existingLock.agent_id === agentId) {\n      fs.unlinkSync(lockFilePath);\n      logActivity('lock_released', agentId, filePath, { operation: 'completed' });\n      return true;\n    }\n    \n    return false;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction shouldExcludeFile(filePath) {\n  return CONFIG.excludePatterns.some(pattern => pattern.test(filePath));\n}\n\nfunction cleanupExpiredLocks() {\n  try {\n    const lockDir = path.join(process.cwd(), CONFIG.lockDirectory);\n    if (!fs.existsSync(lockDir)) return;\n    \n    const lockFiles = fs.readdirSync(lockDir);\n    const now = new Date();\n    \n    for (const lockFile of lockFiles) {\n      if (!lockFile.endsWith('.lock')) continue;\n      \n      const lockFilePath = path.join(lockDir, lockFile);\n      try {\n        const lockData = JSON.parse(fs.readFileSync(lockFilePath, 'utf8'));\n        const expiresAt = new Date(lockData.expires_at);\n        \n        if (now > expiresAt) {\n          fs.unlinkSync(lockFilePath);\n          logActivity('lock_expired', lockData.agent_id, lockData.file_path, {});\n        }\n      } catch (error) {\n        // Silent failure\n      }\n    }\n  } catch (error) {\n    // Silent failure\n  }\n}\n\n// Parse input from stdin\nfunction parseInput() {\n  return new Promise((resolve, reject) => {\n    let input = '';\n    \n    process.stdin.on('data', (chunk) => {\n      input += chunk.toString();\n    });\n    \n    process.stdin.on('end', () => {\n      try {\n        const data = JSON.parse(input);\n        resolve(data);\n      } catch (error) {\n        reject(new Error(`Invalid JSON input: ${error.message}`));\n      }\n    });\n    \n    process.stdin.on('error', reject);\n  });\n}\n\n// Main execution function\nasync function main() {\n  try {\n    // Parse input from Claude Code\n    const input = await parseInput();\n    const { tool_name, tool_input, session_id } = input;\n    \n    // DEBUG: Log everything available for agent identification\n    console.error('=== AGENT ID DEBUG ===');\n    console.error('Input keys:', Object.keys(input));\n    console.error('Full input:', JSON.stringify(input, null, 2));\n    console.error('Process env keys:', Object.keys(process.env).filter(k => k.includes('CLAUDE') || k.includes('SESSION') || k.includes('AGENT')));\n    console.error('process.pid:', process.pid);\n    console.error('process.ppid:', process.ppid);\n    console.error('process.argv:', process.argv);\n    console.error('======================');\n    \n    // Only handle file modification tools\n    if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\n      // Exit with code 0 (success) - allow operation\n      process.exit(0);\n    }\n\n    const filePath = extractFilePath(tool_input);\n    if (!filePath) {\n      // No file path, allow operation\n      process.exit(0);\n    }\n\n    // Check if file should be excluded from locking\n    if (shouldExcludeFile(filePath)) {\n      // Excluded file, allow operation\n      process.exit(0);\n    }\n\n    // Ensure directories exist\n    ensureDirectories();\n\n    const agentId = extractAgentId(input);\n    const operation = tool_name.toLowerCase();\n\n    // Clean up any expired locks first\n    cleanupExpiredLocks();\n\n    // Direct phase detection from Claude Code hook event name\n    const hookPhase = detectHookPhase(input);\n    \n    if (hookPhase === 'PostToolUse') {\n      // PostToolUse: Release lock and allow\n      const released = releaseLock(filePath, agentId);\n      console.log(released ? `Lock released for \"${filePath}\"` : `No lock to release for \"${filePath}\"`);\n      process.exit(0);\n    }\n\n    // PreToolUse: Check locks and potentially block\n    const existingLock = isLocked(filePath);\n    \n    if (existingLock) {\n      if (existingLock.agent_id === agentId) {\n        // Same agent already has the lock, allow operation\n        console.log(`File already locked by this agent: ${filePath}`);\n        process.exit(0);\n      } else {\n        // File locked by different agent, BLOCK operation\n        const timeRemaining = Math.ceil((new Date(existingLock.expires_at) - new Date()) / 1000 / 60);\n        const errorMessage = `File \"${filePath}\" is currently being ${existingLock.operation} by agent \"${existingLock.agent_id}\". Lock expires in ${timeRemaining} minutes. Please wait or work on a different file.`;\n        \n        // Output error to stderr and exit with code 2 (blocking)\n        console.error(errorMessage);\n        process.exit(2);\n      }\n    }\n\n    // File is not locked, create lock and allow operation\n    const lockCreated = createLock(filePath, agentId, operation, session_id);\n    \n    if (lockCreated) {\n      console.log(`File lock acquired for \"${filePath}\"`);\n      process.exit(0);\n    } else {\n      // Lock creation failed, allow operation with warning\n      console.log(`Warning: Could not create file lock for \"${filePath}\", proceeding without lock protection`);\n      process.exit(0);\n    }\n\n  } catch (error) {\n    // Log error but don't block operation (exit code 1 = non-blocking error)\n    console.error(`File lock check failed: ${error.message}`);\n    process.exit(1);\n  }\n}\n\n// Execute if called directly\nif (require.main === module) {\n  main();\n}","structuredPatch":[{"oldStart":50,"oldLines":7,"newStart":50,"newLines":7,"lines":[" function pathToLockName(filePath) {","   return filePath","     .replace(/^\\.?\\/+/, '')","-    .replace(/[\\/\\\\]/g, '-')","+    .replace(/[/\\\\]/g, '-')","     .replace(/[<>:\"|?*]/g, '_')","     + '.lock';"," }"]}],"userModified":false,"replaceAll":false}},"process_pid":161030,"parent_pid":161029,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:21:41.001Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/file-lock-manager.js\",\"old_string\":\"  async execute(input) {\",\"new_string\":\"  execute(input) {\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/file-lock-manager.js\",\"oldString\":\"  async execute(input) {\",\"newString\":\"  execute(input) {\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst LockUtils = require('./lock-utils');\\n\\n/**\\n * File Lock Manager Hook for Claude Code PreToolUse\\n * \\n * This hook intercepts Edit/Write/MultiEdit operations to prevent file conflicts\\n * through a file-level locking mechanism.\\n */\\nclass FileLockManager {\\n  constructor() {\\n    this.lockUtils = new LockUtils();\\n  }\\n\\n  /**\\n   * Parse input from Claude Code hook\\n   * @returns {Promise<Object>} Parsed hook input\\n   */\\n  async parseInput() {\\n    return new Promise((resolve, reject) => {\\n      let input = '';\\n      \\n      process.stdin.on('data', (chunk) => {\\n        input += chunk.toString();\\n      });\\n      \\n      process.stdin.on('end', () => {\\n        try {\\n          const data = JSON.parse(input);\\n          resolve(data);\\n        } catch (error) {\\n          reject(new Error(`Invalid JSON input: ${error.message}`));\\n        }\\n      });\\n      \\n      process.stdin.on('error', reject);\\n    });\\n  }\\n\\n  /**\\n   * Extract file path from tool input\\n   * @param {Object} toolInput - Tool input object\\n   * @returns {string|null} File path or null if not found\\n   */\\n  extractFilePath(toolInput) {\\n    // Handle different tool input formats\\n    return toolInput.file_path || \\n           toolInput.filePath ||\\n           (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\\n           null;\\n  }\\n\\n  /**\\n   * Extract agent ID from hook input\\n   * @param {Object} input - Hook input\\n   * @returns {string} Agent ID\\n   */\\n  extractAgentId(input) {\\n    // Try various ways to extract agent ID\\n    return process.env.MCP_AGENT_ID || \\n           input.agent_id ||\\n           input.session_id ||\\n           'unknown-agent';\\n  }\\n\\n  /**\\n   * Determine operation type from tool name\\n   * @param {string} toolName - Claude Code tool name\\n   * @returns {string} Operation type\\n   */\\n  getOperationType(toolName) {\\n    switch (toolName) {\\n      case 'Edit':\\n      case 'MultiEdit':\\n        return 'editing';\\n      case 'Write':\\n        return 'writing';\\n      default:\\n        return 'modifying';\\n    }\\n  }\\n\\n  /**\\n   * Check if file should be excluded from locking\\n   * @param {string} filePath - File path to check\\n   * @returns {boolean} True if should be excluded\\n   */\\n  shouldExcludeFile(filePath) {\\n    const excludePatterns = [\\n      /\\\\.log$/,\\n      /\\\\.tmp$/,\\n      /\\\\.temp$/,\\n      /\\\\.lock$/,\\n      /\\\\.env/,\\n      /\\\\.git\\\\//,\\n      /\\\\.agent-/,\\n      /node_modules\\\\//,\\n      /\\\\.pyc$/,\\n      /__pycache__\\\\//\\n    ];\\n\\n    return excludePatterns.some(pattern => pattern.test(filePath));\\n  }\\n\\n  /**\\n   * Generate hook response\\n   * @param {string} decision - 'approve', 'block', or undefined\\n   * @param {string} reason - Reason for the decision\\n   * @param {Object} additionalData - Additional response data\\n   * @returns {Object} Hook response\\n   */\\n  generateResponse(decision, reason = null, additionalData = {}) {\\n    const response = {\\n      ...additionalData\\n    };\\n\\n    if (decision) {\\n      response.decision = decision;\\n    }\\n    \\n    if (reason) {\\n      response.reason = reason;\\n    }\\n\\n    return response;\\n  }\\n\\n  /**\\n   * Main execution logic\\n   * @param {Object} input - Hook input from Claude Code\\n   * @returns {Object} Hook response\\n   */\\n  async execute(input) {\\n    try {\\n      const { tool_name, tool_input, session_id } = input;\\n      \\n      // Only handle file modification tools\\n      if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\\n        return this.generateResponse(); // Allow other tools\\n      }\\n\\n      const filePath = this.extractFilePath(tool_input);\\n      if (!filePath) {\\n        return this.generateResponse(); // No file path, allow operation\\n      }\\n\\n      // Check if file should be excluded from locking\\n      if (this.shouldExcludeFile(filePath)) {\\n        return this.generateResponse(); // Excluded file, allow operation\\n      }\\n\\n      const agentId = this.extractAgentId(input);\\n      const operation = this.getOperationType(tool_name);\\n\\n      // Clean up any expired locks first\\n      this.lockUtils.cleanupExpiredLocks();\\n\\n      // Check if file is currently locked\\n      const existingLock = this.lockUtils.isLocked(filePath);\\n      \\n      if (existingLock) {\\n        if (existingLock.agent_id === agentId) {\\n          // Same agent already has the lock, allow operation\\n          return this.generateResponse('approve', `File already locked by this agent`);\\n        } else {\\n          // File locked by different agent, block operation\\n          const timeRemaining = Math.ceil((new Date(existingLock.expires_at) - new Date()) / 1000 / 60);\\n          return this.generateResponse(\\n            'block', \\n            `File \\\"${filePath}\\\" is currently being ${existingLock.operation} by agent \\\"${existingLock.agent_id}\\\". Lock expires in ${timeRemaining} minutes. Please wait or work on a different file.`\\n          );\\n        }\\n      }\\n\\n      // File is not locked, create lock and approve operation\\n      const lockCreated = this.lockUtils.createLock(filePath, agentId, operation, session_id);\\n      \\n      if (lockCreated) {\\n        return this.generateResponse(\\n          'approve', \\n          `File lock acquired for \\\"${filePath}\\\"`\\n        );\\n      } else {\\n        // Lock creation failed, allow operation with warning\\n        return this.generateResponse(\\n          undefined,\\n          `Warning: Could not create file lock for \\\"${filePath}\\\", proceeding without lock protection`\\n        );\\n      }\\n\\n    } catch (error) {\\n      // Log error but don't block operation\\n      console.error(`File lock manager error: ${error.message}`);\\n      return this.generateResponse(\\n        undefined,\\n        `Warning: File lock check failed (${error.message}), proceeding without lock protection`\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Output result to stdout/stderr based on hook protocol\\n   * @param {Object} result - Hook result\\n   */\\n  outputResult(result) {\\n    if (result.decision === 'block') {\\n      // Blocking result - output reason to stderr and exit with code 2\\n      console.error(result.reason);\\n      process.exit(2);\\n    } else if (result.decision === 'approve') {\\n      // Approval result - output JSON to stdout\\n      console.log(JSON.stringify(result));\\n      process.exit(0);\\n    } else {\\n      // Allow operation - output any reason to stdout if present\\n      if (result.reason) {\\n        console.log(result.reason);\\n      }\\n      process.exit(0);\\n    }\\n  }\\n}\\n\\n// CLI execution\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const manager = new FileLockManager();\\n      const input = await manager.parseInput();\\n      const result = await manager.execute(input);\\n      manager.outputResult(result);\\n    } catch (error) {\\n      console.error(`File lock manager error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\\n\\nmodule.exports = FileLockManager;\",\"structuredPatch\":[{\"oldStart\":131,\"oldLines\":7,\"newStart\":131,\"newLines\":7,\"lines\":[\"    * @param {Object} input - Hook input from Claude Code\",\"    * @returns {Object} Hook response\",\"    */\",\"-  async execute(input) {\",\"+  execute(input) {\",\"     try {\",\"       const { tool_name, tool_input, session_id } = input;\",\"       \"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/file-lock-manager.js","old_string":"  async execute(input) {","new_string":"  execute(input) {"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/file-lock-manager.js","oldString":"  async execute(input) {","newString":"  execute(input) {","originalFile":"#!/usr/bin/env node\n\nconst LockUtils = require('./lock-utils');\n\n/**\n * File Lock Manager Hook for Claude Code PreToolUse\n * \n * This hook intercepts Edit/Write/MultiEdit operations to prevent file conflicts\n * through a file-level locking mechanism.\n */\nclass FileLockManager {\n  constructor() {\n    this.lockUtils = new LockUtils();\n  }\n\n  /**\n   * Parse input from Claude Code hook\n   * @returns {Promise<Object>} Parsed hook input\n   */\n  async parseInput() {\n    return new Promise((resolve, reject) => {\n      let input = '';\n      \n      process.stdin.on('data', (chunk) => {\n        input += chunk.toString();\n      });\n      \n      process.stdin.on('end', () => {\n        try {\n          const data = JSON.parse(input);\n          resolve(data);\n        } catch (error) {\n          reject(new Error(`Invalid JSON input: ${error.message}`));\n        }\n      });\n      \n      process.stdin.on('error', reject);\n    });\n  }\n\n  /**\n   * Extract file path from tool input\n   * @param {Object} toolInput - Tool input object\n   * @returns {string|null} File path or null if not found\n   */\n  extractFilePath(toolInput) {\n    // Handle different tool input formats\n    return toolInput.file_path || \n           toolInput.filePath ||\n           (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\n           null;\n  }\n\n  /**\n   * Extract agent ID from hook input\n   * @param {Object} input - Hook input\n   * @returns {string} Agent ID\n   */\n  extractAgentId(input) {\n    // Try various ways to extract agent ID\n    return process.env.MCP_AGENT_ID || \n           input.agent_id ||\n           input.session_id ||\n           'unknown-agent';\n  }\n\n  /**\n   * Determine operation type from tool name\n   * @param {string} toolName - Claude Code tool name\n   * @returns {string} Operation type\n   */\n  getOperationType(toolName) {\n    switch (toolName) {\n      case 'Edit':\n      case 'MultiEdit':\n        return 'editing';\n      case 'Write':\n        return 'writing';\n      default:\n        return 'modifying';\n    }\n  }\n\n  /**\n   * Check if file should be excluded from locking\n   * @param {string} filePath - File path to check\n   * @returns {boolean} True if should be excluded\n   */\n  shouldExcludeFile(filePath) {\n    const excludePatterns = [\n      /\\.log$/,\n      /\\.tmp$/,\n      /\\.temp$/,\n      /\\.lock$/,\n      /\\.env/,\n      /\\.git\\//,\n      /\\.agent-/,\n      /node_modules\\//,\n      /\\.pyc$/,\n      /__pycache__\\//\n    ];\n\n    return excludePatterns.some(pattern => pattern.test(filePath));\n  }\n\n  /**\n   * Generate hook response\n   * @param {string} decision - 'approve', 'block', or undefined\n   * @param {string} reason - Reason for the decision\n   * @param {Object} additionalData - Additional response data\n   * @returns {Object} Hook response\n   */\n  generateResponse(decision, reason = null, additionalData = {}) {\n    const response = {\n      ...additionalData\n    };\n\n    if (decision) {\n      response.decision = decision;\n    }\n    \n    if (reason) {\n      response.reason = reason;\n    }\n\n    return response;\n  }\n\n  /**\n   * Main execution logic\n   * @param {Object} input - Hook input from Claude Code\n   * @returns {Object} Hook response\n   */\n  async execute(input) {\n    try {\n      const { tool_name, tool_input, session_id } = input;\n      \n      // Only handle file modification tools\n      if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\n        return this.generateResponse(); // Allow other tools\n      }\n\n      const filePath = this.extractFilePath(tool_input);\n      if (!filePath) {\n        return this.generateResponse(); // No file path, allow operation\n      }\n\n      // Check if file should be excluded from locking\n      if (this.shouldExcludeFile(filePath)) {\n        return this.generateResponse(); // Excluded file, allow operation\n      }\n\n      const agentId = this.extractAgentId(input);\n      const operation = this.getOperationType(tool_name);\n\n      // Clean up any expired locks first\n      this.lockUtils.cleanupExpiredLocks();\n\n      // Check if file is currently locked\n      const existingLock = this.lockUtils.isLocked(filePath);\n      \n      if (existingLock) {\n        if (existingLock.agent_id === agentId) {\n          // Same agent already has the lock, allow operation\n          return this.generateResponse('approve', `File already locked by this agent`);\n        } else {\n          // File locked by different agent, block operation\n          const timeRemaining = Math.ceil((new Date(existingLock.expires_at) - new Date()) / 1000 / 60);\n          return this.generateResponse(\n            'block', \n            `File \"${filePath}\" is currently being ${existingLock.operation} by agent \"${existingLock.agent_id}\". Lock expires in ${timeRemaining} minutes. Please wait or work on a different file.`\n          );\n        }\n      }\n\n      // File is not locked, create lock and approve operation\n      const lockCreated = this.lockUtils.createLock(filePath, agentId, operation, session_id);\n      \n      if (lockCreated) {\n        return this.generateResponse(\n          'approve', \n          `File lock acquired for \"${filePath}\"`\n        );\n      } else {\n        // Lock creation failed, allow operation with warning\n        return this.generateResponse(\n          undefined,\n          `Warning: Could not create file lock for \"${filePath}\", proceeding without lock protection`\n        );\n      }\n\n    } catch (error) {\n      // Log error but don't block operation\n      console.error(`File lock manager error: ${error.message}`);\n      return this.generateResponse(\n        undefined,\n        `Warning: File lock check failed (${error.message}), proceeding without lock protection`\n      );\n    }\n  }\n\n  /**\n   * Output result to stdout/stderr based on hook protocol\n   * @param {Object} result - Hook result\n   */\n  outputResult(result) {\n    if (result.decision === 'block') {\n      // Blocking result - output reason to stderr and exit with code 2\n      console.error(result.reason);\n      process.exit(2);\n    } else if (result.decision === 'approve') {\n      // Approval result - output JSON to stdout\n      console.log(JSON.stringify(result));\n      process.exit(0);\n    } else {\n      // Allow operation - output any reason to stdout if present\n      if (result.reason) {\n        console.log(result.reason);\n      }\n      process.exit(0);\n    }\n  }\n}\n\n// CLI execution\nif (require.main === module) {\n  (async () => {\n    try {\n      const manager = new FileLockManager();\n      const input = await manager.parseInput();\n      const result = await manager.execute(input);\n      manager.outputResult(result);\n    } catch (error) {\n      console.error(`File lock manager error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}\n\nmodule.exports = FileLockManager;","structuredPatch":[{"oldStart":131,"oldLines":7,"newStart":131,"newLines":7,"lines":["    * @param {Object} input - Hook input from Claude Code","    * @returns {Object} Hook response","    */","-  async execute(input) {","+  execute(input) {","     try {","       const { tool_name, tool_input, session_id } = input;","       "]}],"userModified":false,"replaceAll":false}},"process_pid":161083,"parent_pid":161082,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:21:51.839Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/file-lock-manager.js\",\"old_string\":\"  async parseInput() {\",\"new_string\":\"  parseInput() {\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/file-lock-manager.js\",\"oldString\":\"  async parseInput() {\",\"newString\":\"  parseInput() {\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst LockUtils = require('./lock-utils');\\n\\n/**\\n * File Lock Manager Hook for Claude Code PreToolUse\\n * \\n * This hook intercepts Edit/Write/MultiEdit operations to prevent file conflicts\\n * through a file-level locking mechanism.\\n */\\nclass FileLockManager {\\n  constructor() {\\n    this.lockUtils = new LockUtils();\\n  }\\n\\n  /**\\n   * Parse input from Claude Code hook\\n   * @returns {Promise<Object>} Parsed hook input\\n   */\\n  async parseInput() {\\n    return new Promise((resolve, reject) => {\\n      let input = '';\\n      \\n      process.stdin.on('data', (chunk) => {\\n        input += chunk.toString();\\n      });\\n      \\n      process.stdin.on('end', () => {\\n        try {\\n          const data = JSON.parse(input);\\n          resolve(data);\\n        } catch (error) {\\n          reject(new Error(`Invalid JSON input: ${error.message}`));\\n        }\\n      });\\n      \\n      process.stdin.on('error', reject);\\n    });\\n  }\\n\\n  /**\\n   * Extract file path from tool input\\n   * @param {Object} toolInput - Tool input object\\n   * @returns {string|null} File path or null if not found\\n   */\\n  extractFilePath(toolInput) {\\n    // Handle different tool input formats\\n    return toolInput.file_path || \\n           toolInput.filePath ||\\n           (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\\n           null;\\n  }\\n\\n  /**\\n   * Extract agent ID from hook input\\n   * @param {Object} input - Hook input\\n   * @returns {string} Agent ID\\n   */\\n  extractAgentId(input) {\\n    // Try various ways to extract agent ID\\n    return process.env.MCP_AGENT_ID || \\n           input.agent_id ||\\n           input.session_id ||\\n           'unknown-agent';\\n  }\\n\\n  /**\\n   * Determine operation type from tool name\\n   * @param {string} toolName - Claude Code tool name\\n   * @returns {string} Operation type\\n   */\\n  getOperationType(toolName) {\\n    switch (toolName) {\\n      case 'Edit':\\n      case 'MultiEdit':\\n        return 'editing';\\n      case 'Write':\\n        return 'writing';\\n      default:\\n        return 'modifying';\\n    }\\n  }\\n\\n  /**\\n   * Check if file should be excluded from locking\\n   * @param {string} filePath - File path to check\\n   * @returns {boolean} True if should be excluded\\n   */\\n  shouldExcludeFile(filePath) {\\n    const excludePatterns = [\\n      /\\\\.log$/,\\n      /\\\\.tmp$/,\\n      /\\\\.temp$/,\\n      /\\\\.lock$/,\\n      /\\\\.env/,\\n      /\\\\.git\\\\//,\\n      /\\\\.agent-/,\\n      /node_modules\\\\//,\\n      /\\\\.pyc$/,\\n      /__pycache__\\\\//\\n    ];\\n\\n    return excludePatterns.some(pattern => pattern.test(filePath));\\n  }\\n\\n  /**\\n   * Generate hook response\\n   * @param {string} decision - 'approve', 'block', or undefined\\n   * @param {string} reason - Reason for the decision\\n   * @param {Object} additionalData - Additional response data\\n   * @returns {Object} Hook response\\n   */\\n  generateResponse(decision, reason = null, additionalData = {}) {\\n    const response = {\\n      ...additionalData\\n    };\\n\\n    if (decision) {\\n      response.decision = decision;\\n    }\\n    \\n    if (reason) {\\n      response.reason = reason;\\n    }\\n\\n    return response;\\n  }\\n\\n  /**\\n   * Main execution logic\\n   * @param {Object} input - Hook input from Claude Code\\n   * @returns {Object} Hook response\\n   */\\n  execute(input) {\\n    try {\\n      const { tool_name, tool_input, session_id } = input;\\n      \\n      // Only handle file modification tools\\n      if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\\n        return this.generateResponse(); // Allow other tools\\n      }\\n\\n      const filePath = this.extractFilePath(tool_input);\\n      if (!filePath) {\\n        return this.generateResponse(); // No file path, allow operation\\n      }\\n\\n      // Check if file should be excluded from locking\\n      if (this.shouldExcludeFile(filePath)) {\\n        return this.generateResponse(); // Excluded file, allow operation\\n      }\\n\\n      const agentId = this.extractAgentId(input);\\n      const operation = this.getOperationType(tool_name);\\n\\n      // Clean up any expired locks first\\n      this.lockUtils.cleanupExpiredLocks();\\n\\n      // Check if file is currently locked\\n      const existingLock = this.lockUtils.isLocked(filePath);\\n      \\n      if (existingLock) {\\n        if (existingLock.agent_id === agentId) {\\n          // Same agent already has the lock, allow operation\\n          return this.generateResponse('approve', `File already locked by this agent`);\\n        } else {\\n          // File locked by different agent, block operation\\n          const timeRemaining = Math.ceil((new Date(existingLock.expires_at) - new Date()) / 1000 / 60);\\n          return this.generateResponse(\\n            'block', \\n            `File \\\"${filePath}\\\" is currently being ${existingLock.operation} by agent \\\"${existingLock.agent_id}\\\". Lock expires in ${timeRemaining} minutes. Please wait or work on a different file.`\\n          );\\n        }\\n      }\\n\\n      // File is not locked, create lock and approve operation\\n      const lockCreated = this.lockUtils.createLock(filePath, agentId, operation, session_id);\\n      \\n      if (lockCreated) {\\n        return this.generateResponse(\\n          'approve', \\n          `File lock acquired for \\\"${filePath}\\\"`\\n        );\\n      } else {\\n        // Lock creation failed, allow operation with warning\\n        return this.generateResponse(\\n          undefined,\\n          `Warning: Could not create file lock for \\\"${filePath}\\\", proceeding without lock protection`\\n        );\\n      }\\n\\n    } catch (error) {\\n      // Log error but don't block operation\\n      console.error(`File lock manager error: ${error.message}`);\\n      return this.generateResponse(\\n        undefined,\\n        `Warning: File lock check failed (${error.message}), proceeding without lock protection`\\n      );\\n    }\\n  }\\n\\n  /**\\n   * Output result to stdout/stderr based on hook protocol\\n   * @param {Object} result - Hook result\\n   */\\n  outputResult(result) {\\n    if (result.decision === 'block') {\\n      // Blocking result - output reason to stderr and exit with code 2\\n      console.error(result.reason);\\n      process.exit(2);\\n    } else if (result.decision === 'approve') {\\n      // Approval result - output JSON to stdout\\n      console.log(JSON.stringify(result));\\n      process.exit(0);\\n    } else {\\n      // Allow operation - output any reason to stdout if present\\n      if (result.reason) {\\n        console.log(result.reason);\\n      }\\n      process.exit(0);\\n    }\\n  }\\n}\\n\\n// CLI execution\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const manager = new FileLockManager();\\n      const input = await manager.parseInput();\\n      const result = await manager.execute(input);\\n      manager.outputResult(result);\\n    } catch (error) {\\n      console.error(`File lock manager error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\\n\\nmodule.exports = FileLockManager;\",\"structuredPatch\":[{\"oldStart\":17,\"oldLines\":7,\"newStart\":17,\"newLines\":7,\"lines\":[\"    * Parse input from Claude Code hook\",\"    * @returns {Promise<Object>} Parsed hook input\",\"    */\",\"-  async parseInput() {\",\"+  parseInput() {\",\"     return new Promise((resolve, reject) => {\",\"       let input = '';\",\"       \"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/file-lock-manager.js","old_string":"  async parseInput() {","new_string":"  parseInput() {"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/file-lock-manager.js","oldString":"  async parseInput() {","newString":"  parseInput() {","originalFile":"#!/usr/bin/env node\n\nconst LockUtils = require('./lock-utils');\n\n/**\n * File Lock Manager Hook for Claude Code PreToolUse\n * \n * This hook intercepts Edit/Write/MultiEdit operations to prevent file conflicts\n * through a file-level locking mechanism.\n */\nclass FileLockManager {\n  constructor() {\n    this.lockUtils = new LockUtils();\n  }\n\n  /**\n   * Parse input from Claude Code hook\n   * @returns {Promise<Object>} Parsed hook input\n   */\n  async parseInput() {\n    return new Promise((resolve, reject) => {\n      let input = '';\n      \n      process.stdin.on('data', (chunk) => {\n        input += chunk.toString();\n      });\n      \n      process.stdin.on('end', () => {\n        try {\n          const data = JSON.parse(input);\n          resolve(data);\n        } catch (error) {\n          reject(new Error(`Invalid JSON input: ${error.message}`));\n        }\n      });\n      \n      process.stdin.on('error', reject);\n    });\n  }\n\n  /**\n   * Extract file path from tool input\n   * @param {Object} toolInput - Tool input object\n   * @returns {string|null} File path or null if not found\n   */\n  extractFilePath(toolInput) {\n    // Handle different tool input formats\n    return toolInput.file_path || \n           toolInput.filePath ||\n           (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\n           null;\n  }\n\n  /**\n   * Extract agent ID from hook input\n   * @param {Object} input - Hook input\n   * @returns {string} Agent ID\n   */\n  extractAgentId(input) {\n    // Try various ways to extract agent ID\n    return process.env.MCP_AGENT_ID || \n           input.agent_id ||\n           input.session_id ||\n           'unknown-agent';\n  }\n\n  /**\n   * Determine operation type from tool name\n   * @param {string} toolName - Claude Code tool name\n   * @returns {string} Operation type\n   */\n  getOperationType(toolName) {\n    switch (toolName) {\n      case 'Edit':\n      case 'MultiEdit':\n        return 'editing';\n      case 'Write':\n        return 'writing';\n      default:\n        return 'modifying';\n    }\n  }\n\n  /**\n   * Check if file should be excluded from locking\n   * @param {string} filePath - File path to check\n   * @returns {boolean} True if should be excluded\n   */\n  shouldExcludeFile(filePath) {\n    const excludePatterns = [\n      /\\.log$/,\n      /\\.tmp$/,\n      /\\.temp$/,\n      /\\.lock$/,\n      /\\.env/,\n      /\\.git\\//,\n      /\\.agent-/,\n      /node_modules\\//,\n      /\\.pyc$/,\n      /__pycache__\\//\n    ];\n\n    return excludePatterns.some(pattern => pattern.test(filePath));\n  }\n\n  /**\n   * Generate hook response\n   * @param {string} decision - 'approve', 'block', or undefined\n   * @param {string} reason - Reason for the decision\n   * @param {Object} additionalData - Additional response data\n   * @returns {Object} Hook response\n   */\n  generateResponse(decision, reason = null, additionalData = {}) {\n    const response = {\n      ...additionalData\n    };\n\n    if (decision) {\n      response.decision = decision;\n    }\n    \n    if (reason) {\n      response.reason = reason;\n    }\n\n    return response;\n  }\n\n  /**\n   * Main execution logic\n   * @param {Object} input - Hook input from Claude Code\n   * @returns {Object} Hook response\n   */\n  execute(input) {\n    try {\n      const { tool_name, tool_input, session_id } = input;\n      \n      // Only handle file modification tools\n      if (!['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\n        return this.generateResponse(); // Allow other tools\n      }\n\n      const filePath = this.extractFilePath(tool_input);\n      if (!filePath) {\n        return this.generateResponse(); // No file path, allow operation\n      }\n\n      // Check if file should be excluded from locking\n      if (this.shouldExcludeFile(filePath)) {\n        return this.generateResponse(); // Excluded file, allow operation\n      }\n\n      const agentId = this.extractAgentId(input);\n      const operation = this.getOperationType(tool_name);\n\n      // Clean up any expired locks first\n      this.lockUtils.cleanupExpiredLocks();\n\n      // Check if file is currently locked\n      const existingLock = this.lockUtils.isLocked(filePath);\n      \n      if (existingLock) {\n        if (existingLock.agent_id === agentId) {\n          // Same agent already has the lock, allow operation\n          return this.generateResponse('approve', `File already locked by this agent`);\n        } else {\n          // File locked by different agent, block operation\n          const timeRemaining = Math.ceil((new Date(existingLock.expires_at) - new Date()) / 1000 / 60);\n          return this.generateResponse(\n            'block', \n            `File \"${filePath}\" is currently being ${existingLock.operation} by agent \"${existingLock.agent_id}\". Lock expires in ${timeRemaining} minutes. Please wait or work on a different file.`\n          );\n        }\n      }\n\n      // File is not locked, create lock and approve operation\n      const lockCreated = this.lockUtils.createLock(filePath, agentId, operation, session_id);\n      \n      if (lockCreated) {\n        return this.generateResponse(\n          'approve', \n          `File lock acquired for \"${filePath}\"`\n        );\n      } else {\n        // Lock creation failed, allow operation with warning\n        return this.generateResponse(\n          undefined,\n          `Warning: Could not create file lock for \"${filePath}\", proceeding without lock protection`\n        );\n      }\n\n    } catch (error) {\n      // Log error but don't block operation\n      console.error(`File lock manager error: ${error.message}`);\n      return this.generateResponse(\n        undefined,\n        `Warning: File lock check failed (${error.message}), proceeding without lock protection`\n      );\n    }\n  }\n\n  /**\n   * Output result to stdout/stderr based on hook protocol\n   * @param {Object} result - Hook result\n   */\n  outputResult(result) {\n    if (result.decision === 'block') {\n      // Blocking result - output reason to stderr and exit with code 2\n      console.error(result.reason);\n      process.exit(2);\n    } else if (result.decision === 'approve') {\n      // Approval result - output JSON to stdout\n      console.log(JSON.stringify(result));\n      process.exit(0);\n    } else {\n      // Allow operation - output any reason to stdout if present\n      if (result.reason) {\n        console.log(result.reason);\n      }\n      process.exit(0);\n    }\n  }\n}\n\n// CLI execution\nif (require.main === module) {\n  (async () => {\n    try {\n      const manager = new FileLockManager();\n      const input = await manager.parseInput();\n      const result = await manager.execute(input);\n      manager.outputResult(result);\n    } catch (error) {\n      console.error(`File lock manager error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}\n\nmodule.exports = FileLockManager;","structuredPatch":[{"oldStart":17,"oldLines":7,"newStart":17,"newLines":7,"lines":["    * Parse input from Claude Code hook","    * @returns {Promise<Object>} Parsed hook input","    */","-  async parseInput() {","+  parseInput() {","     return new Promise((resolve, reject) => {","       let input = '';","       "]}],"userModified":false,"replaceAll":false}},"process_pid":161133,"parent_pid":161132,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:22:03.156Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/cleanup-locks.js\",\"old_string\":\"const LockUtils = require('./lock-utils');\\nconst path = require('path');\",\"new_string\":\"const LockUtils = require('./lock-utils');\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/cleanup-locks.js\",\"oldString\":\"const LockUtils = require('./lock-utils');\\nconst path = require('path');\",\"newString\":\"const LockUtils = require('./lock-utils');\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst LockUtils = require('./lock-utils');\\nconst path = require('path');\\n\\n/**\\n * Lock cleanup utility for administrative tasks\\n */\\nclass LockCleanup {\\n  constructor() {\\n    this.lockUtils = new LockUtils();\\n  }\\n\\n  /**\\n   * Display current lock status\\n   */\\n  showStatus() {\\n    console.log('=== Agent File Lock Status ===\\\\n');\\n    \\n    const locks = this.lockUtils.getAllLocks();\\n    \\n    if (locks.length === 0) {\\n      console.log('No active file locks.');\\n      return;\\n    }\\n\\n    console.log(`Found ${locks.length} active lock(s):\\\\n`);\\n    \\n    locks.forEach((lock, index) => {\\n      const timeRemaining = Math.ceil((new Date(lock.expires_at) - new Date()) / 1000 / 60);\\n      console.log(`${index + 1}. File: ${lock.file_path}`);\\n      console.log(`   Agent: ${lock.agent_id}`);\\n      console.log(`   Operation: ${lock.operation}`);\\n      console.log(`   Locked: ${new Date(lock.locked_at).toLocaleString()}`);\\n      console.log(`   Expires: ${timeRemaining} minutes`);\\n      console.log(`   Session: ${lock.session_id}`);\\n      console.log('');\\n    });\\n  }\\n\\n  /**\\n   * Clean up expired locks\\n   */\\n  cleanExpired() {\\n    console.log('Cleaning up expired locks...');\\n    const cleaned = this.lockUtils.cleanupExpiredLocks();\\n    console.log(`Cleaned up ${cleaned} expired lock(s).`);\\n  }\\n\\n  /**\\n   * Release all locks for a specific agent\\n   * @param {string} agentId - Agent ID\\n   */\\n  releaseAgent(agentId) {\\n    console.log(`Releasing all locks for agent: ${agentId}`);\\n    const released = this.lockUtils.releaseAllLocks(agentId);\\n    console.log(`Released ${released} lock(s) for agent ${agentId}.`);\\n  }\\n\\n  /**\\n   * Force release a specific file lock\\n   * @param {string} filePath - File path to unlock\\n   */\\n  forceRelease(filePath) {\\n    console.log(`Force releasing lock for file: ${filePath}`);\\n    const released = this.lockUtils.releaseLock(filePath);\\n    if (released) {\\n      console.log(`Successfully released lock for ${filePath}.`);\\n    } else {\\n      console.log(`No lock found for ${filePath} or release failed.`);\\n    }\\n  }\\n\\n  /**\\n   * Show help information\\n   */\\n  showHelp() {\\n    console.log('Agent File Lock Management Utility\\\\n');\\n    console.log('Usage: node cleanup-locks.js <command> [options]\\\\n');\\n    console.log('Commands:');\\n    console.log('  status                    Show current lock status');\\n    console.log('  clean                     Clean up expired locks');\\n    console.log('  release-agent <agent_id>  Release all locks for an agent');\\n    console.log('  force-release <file_path> Force release lock for a file');\\n    console.log('  help                      Show this help message\\\\n');\\n    console.log('Examples:');\\n    console.log('  node cleanup-locks.js status');\\n    console.log('  node cleanup-locks.js clean');\\n    console.log('  node cleanup-locks.js release-agent worker1');\\n    console.log('  node cleanup-locks.js force-release src/main.py');\\n  }\\n}\\n\\n// CLI execution\\nif (require.main === module) {\\n  const cleanup = new LockCleanup();\\n  const args = process.argv.slice(2);\\n  \\n  if (args.length === 0) {\\n    cleanup.showHelp();\\n    process.exit(0);\\n  }\\n\\n  const command = args[0];\\n  \\n  try {\\n    switch (command) {\\n      case 'status':\\n        cleanup.showStatus();\\n        break;\\n        \\n      case 'clean':\\n        cleanup.cleanExpired();\\n        break;\\n        \\n      case 'release-agent':\\n        if (args.length < 2) {\\n          console.error('Error: Agent ID required for release-agent command');\\n          process.exit(1);\\n        }\\n        cleanup.releaseAgent(args[1]);\\n        break;\\n        \\n      case 'force-release':\\n        if (args.length < 2) {\\n          console.error('Error: File path required for force-release command');\\n          process.exit(1);\\n        }\\n        cleanup.forceRelease(args[1]);\\n        break;\\n        \\n      case 'help':\\n        cleanup.showHelp();\\n        break;\\n        \\n      default:\\n        console.error(`Error: Unknown command '${command}'`);\\n        cleanup.showHelp();\\n        process.exit(1);\\n    }\\n  } catch (error) {\\n    console.error(`Error: ${error.message}`);\\n    process.exit(1);\\n  }\\n}\\n\\nmodule.exports = LockCleanup;\",\"structuredPatch\":[{\"oldStart\":1,\"oldLines\":7,\"newStart\":1,\"newLines\":6,\"lines\":[\" #!/usr/bin/env node\",\" \",\" const LockUtils = require('./lock-utils');\",\"-const path = require('path');\",\" \",\" /**\",\"  * Lock cleanup utility for administrative tasks\"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/cleanup-locks.js","old_string":"const LockUtils = require('./lock-utils');\nconst path = require('path');","new_string":"const LockUtils = require('./lock-utils');"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/cleanup-locks.js","oldString":"const LockUtils = require('./lock-utils');\nconst path = require('path');","newString":"const LockUtils = require('./lock-utils');","originalFile":"#!/usr/bin/env node\n\nconst LockUtils = require('./lock-utils');\nconst path = require('path');\n\n/**\n * Lock cleanup utility for administrative tasks\n */\nclass LockCleanup {\n  constructor() {\n    this.lockUtils = new LockUtils();\n  }\n\n  /**\n   * Display current lock status\n   */\n  showStatus() {\n    console.log('=== Agent File Lock Status ===\\n');\n    \n    const locks = this.lockUtils.getAllLocks();\n    \n    if (locks.length === 0) {\n      console.log('No active file locks.');\n      return;\n    }\n\n    console.log(`Found ${locks.length} active lock(s):\\n`);\n    \n    locks.forEach((lock, index) => {\n      const timeRemaining = Math.ceil((new Date(lock.expires_at) - new Date()) / 1000 / 60);\n      console.log(`${index + 1}. File: ${lock.file_path}`);\n      console.log(`   Agent: ${lock.agent_id}`);\n      console.log(`   Operation: ${lock.operation}`);\n      console.log(`   Locked: ${new Date(lock.locked_at).toLocaleString()}`);\n      console.log(`   Expires: ${timeRemaining} minutes`);\n      console.log(`   Session: ${lock.session_id}`);\n      console.log('');\n    });\n  }\n\n  /**\n   * Clean up expired locks\n   */\n  cleanExpired() {\n    console.log('Cleaning up expired locks...');\n    const cleaned = this.lockUtils.cleanupExpiredLocks();\n    console.log(`Cleaned up ${cleaned} expired lock(s).`);\n  }\n\n  /**\n   * Release all locks for a specific agent\n   * @param {string} agentId - Agent ID\n   */\n  releaseAgent(agentId) {\n    console.log(`Releasing all locks for agent: ${agentId}`);\n    const released = this.lockUtils.releaseAllLocks(agentId);\n    console.log(`Released ${released} lock(s) for agent ${agentId}.`);\n  }\n\n  /**\n   * Force release a specific file lock\n   * @param {string} filePath - File path to unlock\n   */\n  forceRelease(filePath) {\n    console.log(`Force releasing lock for file: ${filePath}`);\n    const released = this.lockUtils.releaseLock(filePath);\n    if (released) {\n      console.log(`Successfully released lock for ${filePath}.`);\n    } else {\n      console.log(`No lock found for ${filePath} or release failed.`);\n    }\n  }\n\n  /**\n   * Show help information\n   */\n  showHelp() {\n    console.log('Agent File Lock Management Utility\\n');\n    console.log('Usage: node cleanup-locks.js <command> [options]\\n');\n    console.log('Commands:');\n    console.log('  status                    Show current lock status');\n    console.log('  clean                     Clean up expired locks');\n    console.log('  release-agent <agent_id>  Release all locks for an agent');\n    console.log('  force-release <file_path> Force release lock for a file');\n    console.log('  help                      Show this help message\\n');\n    console.log('Examples:');\n    console.log('  node cleanup-locks.js status');\n    console.log('  node cleanup-locks.js clean');\n    console.log('  node cleanup-locks.js release-agent worker1');\n    console.log('  node cleanup-locks.js force-release src/main.py');\n  }\n}\n\n// CLI execution\nif (require.main === module) {\n  const cleanup = new LockCleanup();\n  const args = process.argv.slice(2);\n  \n  if (args.length === 0) {\n    cleanup.showHelp();\n    process.exit(0);\n  }\n\n  const command = args[0];\n  \n  try {\n    switch (command) {\n      case 'status':\n        cleanup.showStatus();\n        break;\n        \n      case 'clean':\n        cleanup.cleanExpired();\n        break;\n        \n      case 'release-agent':\n        if (args.length < 2) {\n          console.error('Error: Agent ID required for release-agent command');\n          process.exit(1);\n        }\n        cleanup.releaseAgent(args[1]);\n        break;\n        \n      case 'force-release':\n        if (args.length < 2) {\n          console.error('Error: File path required for force-release command');\n          process.exit(1);\n        }\n        cleanup.forceRelease(args[1]);\n        break;\n        \n      case 'help':\n        cleanup.showHelp();\n        break;\n        \n      default:\n        console.error(`Error: Unknown command '${command}'`);\n        cleanup.showHelp();\n        process.exit(1);\n    }\n  } catch (error) {\n    console.error(`Error: ${error.message}`);\n    process.exit(1);\n  }\n}\n\nmodule.exports = LockCleanup;","structuredPatch":[{"oldStart":1,"oldLines":7,"newStart":1,"newLines":6,"lines":[" #!/usr/bin/env node"," "," const LockUtils = require('./lock-utils');","-const path = require('path');"," "," /**","  * Lock cleanup utility for administrative tasks"]}],"userModified":false,"replaceAll":false}},"process_pid":161226,"parent_pid":161225,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:22:13.534Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/activity-broadcaster.js\",\"old_string\":\"  async execute(input) {\",\"new_string\":\"  execute(input) {\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/activity-broadcaster.js\",\"oldString\":\"  async execute(input) {\",\"newString\":\"  execute(input) {\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst LockUtils = require('./lock-utils');\\nconst fs = require('fs');\\nconst path = require('path');\\n\\n/**\\n * Activity Broadcaster Hook for Claude Code PostToolUse\\n * \\n * This hook logs completed file operations for real-time visibility\\n * and releases file locks after successful operations.\\n */\\nclass ActivityBroadcaster {\\n  constructor() {\\n    this.lockUtils = new LockUtils();\\n  }\\n\\n  /**\\n   * Parse input from Claude Code hook\\n   * @returns {Promise<Object>} Parsed hook input\\n   */\\n  async parseInput() {\\n    return new Promise((resolve, reject) => {\\n      let input = '';\\n      \\n      process.stdin.on('data', (chunk) => {\\n        input += chunk.toString();\\n      });\\n      \\n      process.stdin.on('end', () => {\\n        try {\\n          const data = JSON.parse(input);\\n          resolve(data);\\n        } catch (error) {\\n          reject(new Error(`Invalid JSON input: ${error.message}`));\\n        }\\n      });\\n      \\n      process.stdin.on('error', reject);\\n    });\\n  }\\n\\n  /**\\n   * Extract file path from tool input\\n   * @param {Object} toolInput - Tool input object\\n   * @returns {string|null} File path or null if not found\\n   */\\n  extractFilePath(toolInput) {\\n    return toolInput.file_path || \\n           toolInput.filePath ||\\n           (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\\n           null;\\n  }\\n\\n  /**\\n   * Extract agent ID from hook input\\n   * @param {Object} input - Hook input\\n   * @returns {string} Agent ID\\n   */\\n  extractAgentId(input) {\\n    return process.env.MCP_AGENT_ID || \\n           input.agent_id ||\\n           input.session_id ||\\n           'unknown-agent';\\n  }\\n\\n  /**\\n   * Analyze tool response for additional details\\n   * @param {Object} toolResponse - Tool response object\\n   * @returns {Object} Analysis details\\n   */\\n  analyzeToolResponse(toolResponse) {\\n    const details = {};\\n    \\n    if (toolResponse) {\\n      // Extract success status\\n      details.success = toolResponse.success !== false;\\n      \\n      // Extract any error information\\n      if (toolResponse.error) {\\n        details.error = toolResponse.error;\\n      }\\n      \\n      // Extract file information if available\\n      if (toolResponse.filePath) {\\n        details.actual_file_path = toolResponse.filePath;\\n      }\\n      \\n      // Extract content length for write operations\\n      if (toolResponse.content && typeof toolResponse.content === 'string') {\\n        details.content_length = toolResponse.content.length;\\n        details.lines_written = toolResponse.content.split('\\\\n').length;\\n      }\\n    }\\n    \\n    return details;\\n  }\\n\\n  /**\\n   * Get file statistics\\n   * @param {string} filePath - File path\\n   * @returns {Object} File statistics\\n   */\\n  getFileStats(filePath) {\\n    try {\\n      if (fs.existsSync(filePath)) {\\n        const stats = fs.statSync(filePath);\\n        const content = fs.readFileSync(filePath, 'utf8');\\n        \\n        return {\\n          size_bytes: stats.size,\\n          modified_at: stats.mtime.toISOString(),\\n          lines_total: content.split('\\\\n').length,\\n          file_exists: true\\n        };\\n      } else {\\n        return {\\n          file_exists: false\\n        };\\n      }\\n    } catch (error) {\\n      return {\\n        file_exists: false,\\n        stat_error: error.message\\n      };\\n    }\\n  }\\n\\n  /**\\n   * Update agent status\\n   * @param {string} agentId - Agent ID\\n   * @param {string} status - Current status\\n   * @param {Object} details - Additional details\\n   */\\n  updateAgentStatus(agentId, status, details = {}) {\\n    try {\\n      const statusFile = path.join(this.lockUtils.activityDir, 'agent-status.json');\\n      let agentStatuses = {};\\n      \\n      // Load existing statuses\\n      if (fs.existsSync(statusFile)) {\\n        try {\\n          agentStatuses = JSON.parse(fs.readFileSync(statusFile, 'utf8'));\\n        } catch (error) {\\n          console.warn(`Warning: Could not parse agent status file: ${error.message}`);\\n        }\\n      }\\n      \\n      // Update status for this agent\\n      agentStatuses[agentId] = {\\n        status: status,\\n        last_activity: new Date().toISOString(),\\n        ...details\\n      };\\n      \\n      // Write back to file\\n      fs.writeFileSync(statusFile, JSON.stringify(agentStatuses, null, 2));\\n    } catch (error) {\\n      console.warn(`Warning: Could not update agent status: ${error.message}`);\\n    }\\n  }\\n\\n  /**\\n   * Log detailed activity information\\n   * @param {Object} activityData - Activity data to log\\n   */\\n  logDetailedActivity(activityData) {\\n    try {\\n      const activityFile = path.join(this.lockUtils.activityDir, 'live-feed.jsonl');\\n      const entry = {\\n        timestamp: new Date().toISOString(),\\n        ...activityData\\n      };\\n      \\n      fs.appendFileSync(activityFile, JSON.stringify(entry) + '\\\\n');\\n    } catch (error) {\\n      console.warn(`Warning: Could not log detailed activity: ${error.message}`);\\n    }\\n  }\\n\\n  /**\\n   * Check if file should be excluded from activity logging\\n   * @param {string} filePath - File path to check\\n   * @returns {boolean} True if should be excluded\\n   */\\n  shouldExcludeFile(filePath) {\\n    const excludePatterns = [\\n      /\\\\.log$/,\\n      /\\\\.tmp$/,\\n      /\\\\.temp$/,\\n      /\\\\.lock$/,\\n      /\\\\.agent-/,\\n      /\\\\.git\\\\//,\\n      /node_modules\\\\//\\n    ];\\n\\n    return excludePatterns.some(pattern => pattern.test(filePath));\\n  }\\n\\n  /**\\n   * Main execution logic\\n   * @param {Object} input - Hook input from Claude Code\\n   * @returns {Object} Hook response\\n   */\\n  async execute(input) {\\n    try {\\n      const { tool_name, tool_input, tool_response, session_id } = input;\\n      \\n      // Handle all tool operations for visibility\\n      const filePath = this.extractFilePath(tool_input);\\n      const agentId = this.extractAgentId(input);\\n      \\n      // Basic activity logging for all operations\\n      const baseActivity = {\\n        action: 'tool_completed',\\n        agent_id: agentId,\\n        tool_name: tool_name,\\n        session_id: session_id,\\n        file_path: filePath\\n      };\\n\\n      // If it's a file operation, add detailed information\\n      if (filePath && !this.shouldExcludeFile(filePath)) {\\n        const responseDetails = this.analyzeToolResponse(tool_response);\\n        const fileStats = this.getFileStats(filePath);\\n        \\n        const detailedActivity = {\\n          ...baseActivity,\\n          response_details: responseDetails,\\n          file_stats: fileStats,\\n          operation_successful: responseDetails.success !== false\\n        };\\n\\n        this.logDetailedActivity(detailedActivity);\\n\\n        // Release file lock for modification operations\\n        if (['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\\n          const lockReleased = this.lockUtils.releaseLock(filePath, agentId);\\n          \\n          if (lockReleased) {\\n            this.logDetailedActivity({\\n              action: 'lock_released',\\n              agent_id: agentId,\\n              file_path: filePath,\\n              reason: 'operation_completed',\\n              tool_name: tool_name\\n            });\\n          }\\n\\n          // Update agent status\\n          this.updateAgentStatus(agentId, 'idle', {\\n            last_file: filePath,\\n            last_operation: tool_name.toLowerCase(),\\n            operations_completed: (input.operations_completed || 0) + 1\\n          });\\n        }\\n      } else {\\n        // Log non-file operations too for complete visibility\\n        this.logDetailedActivity(baseActivity);\\n      }\\n\\n      // Update agent status for all operations\\n      this.updateAgentStatus(agentId, 'active', {\\n        last_tool: tool_name,\\n        last_activity_detail: filePath ? `${tool_name} on ${path.basename(filePath)}` : tool_name\\n      });\\n\\n      // Always return success for PostToolUse hooks\\n      return {\\n        success: true,\\n        message: `Activity logged for ${tool_name}${filePath ? ` on ${path.basename(filePath)}` : ''}`,\\n        agent_id: agentId\\n      };\\n\\n    } catch (error) {\\n      console.error(`Activity broadcaster error: ${error.message}`);\\n      return {\\n        success: false,\\n        error: error.message\\n      };\\n    }\\n  }\\n\\n  /**\\n   * Output result to stdout\\n   * @param {Object} result - Hook result\\n   */\\n  outputResult(result) {\\n    // PostToolUse hooks don't block operations, just log results\\n    if (result.success) {\\n      // Output success message to stdout for transcript\\n      if (result.message) {\\n        console.log(result.message);\\n      }\\n      process.exit(0);\\n    } else {\\n      // Output error to stderr but don't block\\n      console.error(`Activity logging failed: ${result.error}`);\\n      process.exit(1);\\n    }\\n  }\\n}\\n\\n// CLI execution\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const broadcaster = new ActivityBroadcaster();\\n      const input = await broadcaster.parseInput();\\n      const result = await broadcaster.execute(input);\\n      broadcaster.outputResult(result);\\n    } catch (error) {\\n      console.error(`Activity broadcaster error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\\n\\nmodule.exports = ActivityBroadcaster;\",\"structuredPatch\":[{\"oldStart\":202,\"oldLines\":7,\"newStart\":202,\"newLines\":7,\"lines\":[\"    * @param {Object} input - Hook input from Claude Code\",\"    * @returns {Object} Hook response\",\"    */\",\"-  async execute(input) {\",\"+  execute(input) {\",\"     try {\",\"       const { tool_name, tool_input, tool_response, session_id } = input;\",\"       \"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/activity-broadcaster.js","old_string":"  async execute(input) {","new_string":"  execute(input) {"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/activity-broadcaster.js","oldString":"  async execute(input) {","newString":"  execute(input) {","originalFile":"#!/usr/bin/env node\n\nconst LockUtils = require('./lock-utils');\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Activity Broadcaster Hook for Claude Code PostToolUse\n * \n * This hook logs completed file operations for real-time visibility\n * and releases file locks after successful operations.\n */\nclass ActivityBroadcaster {\n  constructor() {\n    this.lockUtils = new LockUtils();\n  }\n\n  /**\n   * Parse input from Claude Code hook\n   * @returns {Promise<Object>} Parsed hook input\n   */\n  async parseInput() {\n    return new Promise((resolve, reject) => {\n      let input = '';\n      \n      process.stdin.on('data', (chunk) => {\n        input += chunk.toString();\n      });\n      \n      process.stdin.on('end', () => {\n        try {\n          const data = JSON.parse(input);\n          resolve(data);\n        } catch (error) {\n          reject(new Error(`Invalid JSON input: ${error.message}`));\n        }\n      });\n      \n      process.stdin.on('error', reject);\n    });\n  }\n\n  /**\n   * Extract file path from tool input\n   * @param {Object} toolInput - Tool input object\n   * @returns {string|null} File path or null if not found\n   */\n  extractFilePath(toolInput) {\n    return toolInput.file_path || \n           toolInput.filePath ||\n           (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\n           null;\n  }\n\n  /**\n   * Extract agent ID from hook input\n   * @param {Object} input - Hook input\n   * @returns {string} Agent ID\n   */\n  extractAgentId(input) {\n    return process.env.MCP_AGENT_ID || \n           input.agent_id ||\n           input.session_id ||\n           'unknown-agent';\n  }\n\n  /**\n   * Analyze tool response for additional details\n   * @param {Object} toolResponse - Tool response object\n   * @returns {Object} Analysis details\n   */\n  analyzeToolResponse(toolResponse) {\n    const details = {};\n    \n    if (toolResponse) {\n      // Extract success status\n      details.success = toolResponse.success !== false;\n      \n      // Extract any error information\n      if (toolResponse.error) {\n        details.error = toolResponse.error;\n      }\n      \n      // Extract file information if available\n      if (toolResponse.filePath) {\n        details.actual_file_path = toolResponse.filePath;\n      }\n      \n      // Extract content length for write operations\n      if (toolResponse.content && typeof toolResponse.content === 'string') {\n        details.content_length = toolResponse.content.length;\n        details.lines_written = toolResponse.content.split('\\n').length;\n      }\n    }\n    \n    return details;\n  }\n\n  /**\n   * Get file statistics\n   * @param {string} filePath - File path\n   * @returns {Object} File statistics\n   */\n  getFileStats(filePath) {\n    try {\n      if (fs.existsSync(filePath)) {\n        const stats = fs.statSync(filePath);\n        const content = fs.readFileSync(filePath, 'utf8');\n        \n        return {\n          size_bytes: stats.size,\n          modified_at: stats.mtime.toISOString(),\n          lines_total: content.split('\\n').length,\n          file_exists: true\n        };\n      } else {\n        return {\n          file_exists: false\n        };\n      }\n    } catch (error) {\n      return {\n        file_exists: false,\n        stat_error: error.message\n      };\n    }\n  }\n\n  /**\n   * Update agent status\n   * @param {string} agentId - Agent ID\n   * @param {string} status - Current status\n   * @param {Object} details - Additional details\n   */\n  updateAgentStatus(agentId, status, details = {}) {\n    try {\n      const statusFile = path.join(this.lockUtils.activityDir, 'agent-status.json');\n      let agentStatuses = {};\n      \n      // Load existing statuses\n      if (fs.existsSync(statusFile)) {\n        try {\n          agentStatuses = JSON.parse(fs.readFileSync(statusFile, 'utf8'));\n        } catch (error) {\n          console.warn(`Warning: Could not parse agent status file: ${error.message}`);\n        }\n      }\n      \n      // Update status for this agent\n      agentStatuses[agentId] = {\n        status: status,\n        last_activity: new Date().toISOString(),\n        ...details\n      };\n      \n      // Write back to file\n      fs.writeFileSync(statusFile, JSON.stringify(agentStatuses, null, 2));\n    } catch (error) {\n      console.warn(`Warning: Could not update agent status: ${error.message}`);\n    }\n  }\n\n  /**\n   * Log detailed activity information\n   * @param {Object} activityData - Activity data to log\n   */\n  logDetailedActivity(activityData) {\n    try {\n      const activityFile = path.join(this.lockUtils.activityDir, 'live-feed.jsonl');\n      const entry = {\n        timestamp: new Date().toISOString(),\n        ...activityData\n      };\n      \n      fs.appendFileSync(activityFile, JSON.stringify(entry) + '\\n');\n    } catch (error) {\n      console.warn(`Warning: Could not log detailed activity: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if file should be excluded from activity logging\n   * @param {string} filePath - File path to check\n   * @returns {boolean} True if should be excluded\n   */\n  shouldExcludeFile(filePath) {\n    const excludePatterns = [\n      /\\.log$/,\n      /\\.tmp$/,\n      /\\.temp$/,\n      /\\.lock$/,\n      /\\.agent-/,\n      /\\.git\\//,\n      /node_modules\\//\n    ];\n\n    return excludePatterns.some(pattern => pattern.test(filePath));\n  }\n\n  /**\n   * Main execution logic\n   * @param {Object} input - Hook input from Claude Code\n   * @returns {Object} Hook response\n   */\n  async execute(input) {\n    try {\n      const { tool_name, tool_input, tool_response, session_id } = input;\n      \n      // Handle all tool operations for visibility\n      const filePath = this.extractFilePath(tool_input);\n      const agentId = this.extractAgentId(input);\n      \n      // Basic activity logging for all operations\n      const baseActivity = {\n        action: 'tool_completed',\n        agent_id: agentId,\n        tool_name: tool_name,\n        session_id: session_id,\n        file_path: filePath\n      };\n\n      // If it's a file operation, add detailed information\n      if (filePath && !this.shouldExcludeFile(filePath)) {\n        const responseDetails = this.analyzeToolResponse(tool_response);\n        const fileStats = this.getFileStats(filePath);\n        \n        const detailedActivity = {\n          ...baseActivity,\n          response_details: responseDetails,\n          file_stats: fileStats,\n          operation_successful: responseDetails.success !== false\n        };\n\n        this.logDetailedActivity(detailedActivity);\n\n        // Release file lock for modification operations\n        if (['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\n          const lockReleased = this.lockUtils.releaseLock(filePath, agentId);\n          \n          if (lockReleased) {\n            this.logDetailedActivity({\n              action: 'lock_released',\n              agent_id: agentId,\n              file_path: filePath,\n              reason: 'operation_completed',\n              tool_name: tool_name\n            });\n          }\n\n          // Update agent status\n          this.updateAgentStatus(agentId, 'idle', {\n            last_file: filePath,\n            last_operation: tool_name.toLowerCase(),\n            operations_completed: (input.operations_completed || 0) + 1\n          });\n        }\n      } else {\n        // Log non-file operations too for complete visibility\n        this.logDetailedActivity(baseActivity);\n      }\n\n      // Update agent status for all operations\n      this.updateAgentStatus(agentId, 'active', {\n        last_tool: tool_name,\n        last_activity_detail: filePath ? `${tool_name} on ${path.basename(filePath)}` : tool_name\n      });\n\n      // Always return success for PostToolUse hooks\n      return {\n        success: true,\n        message: `Activity logged for ${tool_name}${filePath ? ` on ${path.basename(filePath)}` : ''}`,\n        agent_id: agentId\n      };\n\n    } catch (error) {\n      console.error(`Activity broadcaster error: ${error.message}`);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Output result to stdout\n   * @param {Object} result - Hook result\n   */\n  outputResult(result) {\n    // PostToolUse hooks don't block operations, just log results\n    if (result.success) {\n      // Output success message to stdout for transcript\n      if (result.message) {\n        console.log(result.message);\n      }\n      process.exit(0);\n    } else {\n      // Output error to stderr but don't block\n      console.error(`Activity logging failed: ${result.error}`);\n      process.exit(1);\n    }\n  }\n}\n\n// CLI execution\nif (require.main === module) {\n  (async () => {\n    try {\n      const broadcaster = new ActivityBroadcaster();\n      const input = await broadcaster.parseInput();\n      const result = await broadcaster.execute(input);\n      broadcaster.outputResult(result);\n    } catch (error) {\n      console.error(`Activity broadcaster error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}\n\nmodule.exports = ActivityBroadcaster;","structuredPatch":[{"oldStart":202,"oldLines":7,"newStart":202,"newLines":7,"lines":["    * @param {Object} input - Hook input from Claude Code","    * @returns {Object} Hook response","    */","-  async execute(input) {","+  execute(input) {","     try {","       const { tool_name, tool_input, tool_response, session_id } = input;","       "]}],"userModified":false,"replaceAll":false}},"process_pid":161282,"parent_pid":161281,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
{"timestamp":"2025-07-22T00:22:24.311Z","raw_input":"{\"session_id\":\"d7811463-700d-41e2-9f52-99e1c456eace\",\"transcript_path\":\"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl\",\"hook_event_name\":\"PostToolUse\",\"tool_name\":\"Edit\",\"tool_input\":{\"file_path\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/activity-broadcaster.js\",\"old_string\":\"  async parseInput() {\",\"new_string\":\"  parseInput() {\"},\"tool_response\":{\"filePath\":\"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/activity-broadcaster.js\",\"oldString\":\"  async parseInput() {\",\"newString\":\"  parseInput() {\",\"originalFile\":\"#!/usr/bin/env node\\n\\nconst LockUtils = require('./lock-utils');\\nconst fs = require('fs');\\nconst path = require('path');\\n\\n/**\\n * Activity Broadcaster Hook for Claude Code PostToolUse\\n * \\n * This hook logs completed file operations for real-time visibility\\n * and releases file locks after successful operations.\\n */\\nclass ActivityBroadcaster {\\n  constructor() {\\n    this.lockUtils = new LockUtils();\\n  }\\n\\n  /**\\n   * Parse input from Claude Code hook\\n   * @returns {Promise<Object>} Parsed hook input\\n   */\\n  async parseInput() {\\n    return new Promise((resolve, reject) => {\\n      let input = '';\\n      \\n      process.stdin.on('data', (chunk) => {\\n        input += chunk.toString();\\n      });\\n      \\n      process.stdin.on('end', () => {\\n        try {\\n          const data = JSON.parse(input);\\n          resolve(data);\\n        } catch (error) {\\n          reject(new Error(`Invalid JSON input: ${error.message}`));\\n        }\\n      });\\n      \\n      process.stdin.on('error', reject);\\n    });\\n  }\\n\\n  /**\\n   * Extract file path from tool input\\n   * @param {Object} toolInput - Tool input object\\n   * @returns {string|null} File path or null if not found\\n   */\\n  extractFilePath(toolInput) {\\n    return toolInput.file_path || \\n           toolInput.filePath ||\\n           (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\\n           null;\\n  }\\n\\n  /**\\n   * Extract agent ID from hook input\\n   * @param {Object} input - Hook input\\n   * @returns {string} Agent ID\\n   */\\n  extractAgentId(input) {\\n    return process.env.MCP_AGENT_ID || \\n           input.agent_id ||\\n           input.session_id ||\\n           'unknown-agent';\\n  }\\n\\n  /**\\n   * Analyze tool response for additional details\\n   * @param {Object} toolResponse - Tool response object\\n   * @returns {Object} Analysis details\\n   */\\n  analyzeToolResponse(toolResponse) {\\n    const details = {};\\n    \\n    if (toolResponse) {\\n      // Extract success status\\n      details.success = toolResponse.success !== false;\\n      \\n      // Extract any error information\\n      if (toolResponse.error) {\\n        details.error = toolResponse.error;\\n      }\\n      \\n      // Extract file information if available\\n      if (toolResponse.filePath) {\\n        details.actual_file_path = toolResponse.filePath;\\n      }\\n      \\n      // Extract content length for write operations\\n      if (toolResponse.content && typeof toolResponse.content === 'string') {\\n        details.content_length = toolResponse.content.length;\\n        details.lines_written = toolResponse.content.split('\\\\n').length;\\n      }\\n    }\\n    \\n    return details;\\n  }\\n\\n  /**\\n   * Get file statistics\\n   * @param {string} filePath - File path\\n   * @returns {Object} File statistics\\n   */\\n  getFileStats(filePath) {\\n    try {\\n      if (fs.existsSync(filePath)) {\\n        const stats = fs.statSync(filePath);\\n        const content = fs.readFileSync(filePath, 'utf8');\\n        \\n        return {\\n          size_bytes: stats.size,\\n          modified_at: stats.mtime.toISOString(),\\n          lines_total: content.split('\\\\n').length,\\n          file_exists: true\\n        };\\n      } else {\\n        return {\\n          file_exists: false\\n        };\\n      }\\n    } catch (error) {\\n      return {\\n        file_exists: false,\\n        stat_error: error.message\\n      };\\n    }\\n  }\\n\\n  /**\\n   * Update agent status\\n   * @param {string} agentId - Agent ID\\n   * @param {string} status - Current status\\n   * @param {Object} details - Additional details\\n   */\\n  updateAgentStatus(agentId, status, details = {}) {\\n    try {\\n      const statusFile = path.join(this.lockUtils.activityDir, 'agent-status.json');\\n      let agentStatuses = {};\\n      \\n      // Load existing statuses\\n      if (fs.existsSync(statusFile)) {\\n        try {\\n          agentStatuses = JSON.parse(fs.readFileSync(statusFile, 'utf8'));\\n        } catch (error) {\\n          console.warn(`Warning: Could not parse agent status file: ${error.message}`);\\n        }\\n      }\\n      \\n      // Update status for this agent\\n      agentStatuses[agentId] = {\\n        status: status,\\n        last_activity: new Date().toISOString(),\\n        ...details\\n      };\\n      \\n      // Write back to file\\n      fs.writeFileSync(statusFile, JSON.stringify(agentStatuses, null, 2));\\n    } catch (error) {\\n      console.warn(`Warning: Could not update agent status: ${error.message}`);\\n    }\\n  }\\n\\n  /**\\n   * Log detailed activity information\\n   * @param {Object} activityData - Activity data to log\\n   */\\n  logDetailedActivity(activityData) {\\n    try {\\n      const activityFile = path.join(this.lockUtils.activityDir, 'live-feed.jsonl');\\n      const entry = {\\n        timestamp: new Date().toISOString(),\\n        ...activityData\\n      };\\n      \\n      fs.appendFileSync(activityFile, JSON.stringify(entry) + '\\\\n');\\n    } catch (error) {\\n      console.warn(`Warning: Could not log detailed activity: ${error.message}`);\\n    }\\n  }\\n\\n  /**\\n   * Check if file should be excluded from activity logging\\n   * @param {string} filePath - File path to check\\n   * @returns {boolean} True if should be excluded\\n   */\\n  shouldExcludeFile(filePath) {\\n    const excludePatterns = [\\n      /\\\\.log$/,\\n      /\\\\.tmp$/,\\n      /\\\\.temp$/,\\n      /\\\\.lock$/,\\n      /\\\\.agent-/,\\n      /\\\\.git\\\\//,\\n      /node_modules\\\\//\\n    ];\\n\\n    return excludePatterns.some(pattern => pattern.test(filePath));\\n  }\\n\\n  /**\\n   * Main execution logic\\n   * @param {Object} input - Hook input from Claude Code\\n   * @returns {Object} Hook response\\n   */\\n  execute(input) {\\n    try {\\n      const { tool_name, tool_input, tool_response, session_id } = input;\\n      \\n      // Handle all tool operations for visibility\\n      const filePath = this.extractFilePath(tool_input);\\n      const agentId = this.extractAgentId(input);\\n      \\n      // Basic activity logging for all operations\\n      const baseActivity = {\\n        action: 'tool_completed',\\n        agent_id: agentId,\\n        tool_name: tool_name,\\n        session_id: session_id,\\n        file_path: filePath\\n      };\\n\\n      // If it's a file operation, add detailed information\\n      if (filePath && !this.shouldExcludeFile(filePath)) {\\n        const responseDetails = this.analyzeToolResponse(tool_response);\\n        const fileStats = this.getFileStats(filePath);\\n        \\n        const detailedActivity = {\\n          ...baseActivity,\\n          response_details: responseDetails,\\n          file_stats: fileStats,\\n          operation_successful: responseDetails.success !== false\\n        };\\n\\n        this.logDetailedActivity(detailedActivity);\\n\\n        // Release file lock for modification operations\\n        if (['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\\n          const lockReleased = this.lockUtils.releaseLock(filePath, agentId);\\n          \\n          if (lockReleased) {\\n            this.logDetailedActivity({\\n              action: 'lock_released',\\n              agent_id: agentId,\\n              file_path: filePath,\\n              reason: 'operation_completed',\\n              tool_name: tool_name\\n            });\\n          }\\n\\n          // Update agent status\\n          this.updateAgentStatus(agentId, 'idle', {\\n            last_file: filePath,\\n            last_operation: tool_name.toLowerCase(),\\n            operations_completed: (input.operations_completed || 0) + 1\\n          });\\n        }\\n      } else {\\n        // Log non-file operations too for complete visibility\\n        this.logDetailedActivity(baseActivity);\\n      }\\n\\n      // Update agent status for all operations\\n      this.updateAgentStatus(agentId, 'active', {\\n        last_tool: tool_name,\\n        last_activity_detail: filePath ? `${tool_name} on ${path.basename(filePath)}` : tool_name\\n      });\\n\\n      // Always return success for PostToolUse hooks\\n      return {\\n        success: true,\\n        message: `Activity logged for ${tool_name}${filePath ? ` on ${path.basename(filePath)}` : ''}`,\\n        agent_id: agentId\\n      };\\n\\n    } catch (error) {\\n      console.error(`Activity broadcaster error: ${error.message}`);\\n      return {\\n        success: false,\\n        error: error.message\\n      };\\n    }\\n  }\\n\\n  /**\\n   * Output result to stdout\\n   * @param {Object} result - Hook result\\n   */\\n  outputResult(result) {\\n    // PostToolUse hooks don't block operations, just log results\\n    if (result.success) {\\n      // Output success message to stdout for transcript\\n      if (result.message) {\\n        console.log(result.message);\\n      }\\n      process.exit(0);\\n    } else {\\n      // Output error to stderr but don't block\\n      console.error(`Activity logging failed: ${result.error}`);\\n      process.exit(1);\\n    }\\n  }\\n}\\n\\n// CLI execution\\nif (require.main === module) {\\n  (async () => {\\n    try {\\n      const broadcaster = new ActivityBroadcaster();\\n      const input = await broadcaster.parseInput();\\n      const result = await broadcaster.execute(input);\\n      broadcaster.outputResult(result);\\n    } catch (error) {\\n      console.error(`Activity broadcaster error: ${error.message}`);\\n      process.exit(1);\\n    }\\n  })();\\n}\\n\\nmodule.exports = ActivityBroadcaster;\",\"structuredPatch\":[{\"oldStart\":19,\"oldLines\":7,\"newStart\":19,\"newLines\":7,\"lines\":[\"    * Parse input from Claude Code hook\",\"    * @returns {Promise<Object>} Parsed hook input\",\"    */\",\"-  async parseInput() {\",\"+  parseInput() {\",\"     return new Promise((resolve, reject) => {\",\"       let input = '';\",\"       \"]}],\"userModified\":false,\"replaceAll\":false}}","parsed_input":{"session_id":"d7811463-700d-41e2-9f52-99e1c456eace","transcript_path":"/home/alejandro/.claude/projects/-home-alejandro-Code-MCP-Hooks-Git-rins-hooks/d7811463-700d-41e2-9f52-99e1c456eace.jsonl","hook_event_name":"PostToolUse","tool_name":"Edit","tool_input":{"file_path":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/activity-broadcaster.js","old_string":"  async parseInput() {","new_string":"  parseInput() {"},"tool_response":{"filePath":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks/hooks/file-locking/activity-broadcaster.js","oldString":"  async parseInput() {","newString":"  parseInput() {","originalFile":"#!/usr/bin/env node\n\nconst LockUtils = require('./lock-utils');\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Activity Broadcaster Hook for Claude Code PostToolUse\n * \n * This hook logs completed file operations for real-time visibility\n * and releases file locks after successful operations.\n */\nclass ActivityBroadcaster {\n  constructor() {\n    this.lockUtils = new LockUtils();\n  }\n\n  /**\n   * Parse input from Claude Code hook\n   * @returns {Promise<Object>} Parsed hook input\n   */\n  async parseInput() {\n    return new Promise((resolve, reject) => {\n      let input = '';\n      \n      process.stdin.on('data', (chunk) => {\n        input += chunk.toString();\n      });\n      \n      process.stdin.on('end', () => {\n        try {\n          const data = JSON.parse(input);\n          resolve(data);\n        } catch (error) {\n          reject(new Error(`Invalid JSON input: ${error.message}`));\n        }\n      });\n      \n      process.stdin.on('error', reject);\n    });\n  }\n\n  /**\n   * Extract file path from tool input\n   * @param {Object} toolInput - Tool input object\n   * @returns {string|null} File path or null if not found\n   */\n  extractFilePath(toolInput) {\n    return toolInput.file_path || \n           toolInput.filePath ||\n           (toolInput.edits && toolInput.edits[0] && toolInput.edits[0].file_path) ||\n           null;\n  }\n\n  /**\n   * Extract agent ID from hook input\n   * @param {Object} input - Hook input\n   * @returns {string} Agent ID\n   */\n  extractAgentId(input) {\n    return process.env.MCP_AGENT_ID || \n           input.agent_id ||\n           input.session_id ||\n           'unknown-agent';\n  }\n\n  /**\n   * Analyze tool response for additional details\n   * @param {Object} toolResponse - Tool response object\n   * @returns {Object} Analysis details\n   */\n  analyzeToolResponse(toolResponse) {\n    const details = {};\n    \n    if (toolResponse) {\n      // Extract success status\n      details.success = toolResponse.success !== false;\n      \n      // Extract any error information\n      if (toolResponse.error) {\n        details.error = toolResponse.error;\n      }\n      \n      // Extract file information if available\n      if (toolResponse.filePath) {\n        details.actual_file_path = toolResponse.filePath;\n      }\n      \n      // Extract content length for write operations\n      if (toolResponse.content && typeof toolResponse.content === 'string') {\n        details.content_length = toolResponse.content.length;\n        details.lines_written = toolResponse.content.split('\\n').length;\n      }\n    }\n    \n    return details;\n  }\n\n  /**\n   * Get file statistics\n   * @param {string} filePath - File path\n   * @returns {Object} File statistics\n   */\n  getFileStats(filePath) {\n    try {\n      if (fs.existsSync(filePath)) {\n        const stats = fs.statSync(filePath);\n        const content = fs.readFileSync(filePath, 'utf8');\n        \n        return {\n          size_bytes: stats.size,\n          modified_at: stats.mtime.toISOString(),\n          lines_total: content.split('\\n').length,\n          file_exists: true\n        };\n      } else {\n        return {\n          file_exists: false\n        };\n      }\n    } catch (error) {\n      return {\n        file_exists: false,\n        stat_error: error.message\n      };\n    }\n  }\n\n  /**\n   * Update agent status\n   * @param {string} agentId - Agent ID\n   * @param {string} status - Current status\n   * @param {Object} details - Additional details\n   */\n  updateAgentStatus(agentId, status, details = {}) {\n    try {\n      const statusFile = path.join(this.lockUtils.activityDir, 'agent-status.json');\n      let agentStatuses = {};\n      \n      // Load existing statuses\n      if (fs.existsSync(statusFile)) {\n        try {\n          agentStatuses = JSON.parse(fs.readFileSync(statusFile, 'utf8'));\n        } catch (error) {\n          console.warn(`Warning: Could not parse agent status file: ${error.message}`);\n        }\n      }\n      \n      // Update status for this agent\n      agentStatuses[agentId] = {\n        status: status,\n        last_activity: new Date().toISOString(),\n        ...details\n      };\n      \n      // Write back to file\n      fs.writeFileSync(statusFile, JSON.stringify(agentStatuses, null, 2));\n    } catch (error) {\n      console.warn(`Warning: Could not update agent status: ${error.message}`);\n    }\n  }\n\n  /**\n   * Log detailed activity information\n   * @param {Object} activityData - Activity data to log\n   */\n  logDetailedActivity(activityData) {\n    try {\n      const activityFile = path.join(this.lockUtils.activityDir, 'live-feed.jsonl');\n      const entry = {\n        timestamp: new Date().toISOString(),\n        ...activityData\n      };\n      \n      fs.appendFileSync(activityFile, JSON.stringify(entry) + '\\n');\n    } catch (error) {\n      console.warn(`Warning: Could not log detailed activity: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if file should be excluded from activity logging\n   * @param {string} filePath - File path to check\n   * @returns {boolean} True if should be excluded\n   */\n  shouldExcludeFile(filePath) {\n    const excludePatterns = [\n      /\\.log$/,\n      /\\.tmp$/,\n      /\\.temp$/,\n      /\\.lock$/,\n      /\\.agent-/,\n      /\\.git\\//,\n      /node_modules\\//\n    ];\n\n    return excludePatterns.some(pattern => pattern.test(filePath));\n  }\n\n  /**\n   * Main execution logic\n   * @param {Object} input - Hook input from Claude Code\n   * @returns {Object} Hook response\n   */\n  execute(input) {\n    try {\n      const { tool_name, tool_input, tool_response, session_id } = input;\n      \n      // Handle all tool operations for visibility\n      const filePath = this.extractFilePath(tool_input);\n      const agentId = this.extractAgentId(input);\n      \n      // Basic activity logging for all operations\n      const baseActivity = {\n        action: 'tool_completed',\n        agent_id: agentId,\n        tool_name: tool_name,\n        session_id: session_id,\n        file_path: filePath\n      };\n\n      // If it's a file operation, add detailed information\n      if (filePath && !this.shouldExcludeFile(filePath)) {\n        const responseDetails = this.analyzeToolResponse(tool_response);\n        const fileStats = this.getFileStats(filePath);\n        \n        const detailedActivity = {\n          ...baseActivity,\n          response_details: responseDetails,\n          file_stats: fileStats,\n          operation_successful: responseDetails.success !== false\n        };\n\n        this.logDetailedActivity(detailedActivity);\n\n        // Release file lock for modification operations\n        if (['Edit', 'Write', 'MultiEdit'].includes(tool_name)) {\n          const lockReleased = this.lockUtils.releaseLock(filePath, agentId);\n          \n          if (lockReleased) {\n            this.logDetailedActivity({\n              action: 'lock_released',\n              agent_id: agentId,\n              file_path: filePath,\n              reason: 'operation_completed',\n              tool_name: tool_name\n            });\n          }\n\n          // Update agent status\n          this.updateAgentStatus(agentId, 'idle', {\n            last_file: filePath,\n            last_operation: tool_name.toLowerCase(),\n            operations_completed: (input.operations_completed || 0) + 1\n          });\n        }\n      } else {\n        // Log non-file operations too for complete visibility\n        this.logDetailedActivity(baseActivity);\n      }\n\n      // Update agent status for all operations\n      this.updateAgentStatus(agentId, 'active', {\n        last_tool: tool_name,\n        last_activity_detail: filePath ? `${tool_name} on ${path.basename(filePath)}` : tool_name\n      });\n\n      // Always return success for PostToolUse hooks\n      return {\n        success: true,\n        message: `Activity logged for ${tool_name}${filePath ? ` on ${path.basename(filePath)}` : ''}`,\n        agent_id: agentId\n      };\n\n    } catch (error) {\n      console.error(`Activity broadcaster error: ${error.message}`);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Output result to stdout\n   * @param {Object} result - Hook result\n   */\n  outputResult(result) {\n    // PostToolUse hooks don't block operations, just log results\n    if (result.success) {\n      // Output success message to stdout for transcript\n      if (result.message) {\n        console.log(result.message);\n      }\n      process.exit(0);\n    } else {\n      // Output error to stderr but don't block\n      console.error(`Activity logging failed: ${result.error}`);\n      process.exit(1);\n    }\n  }\n}\n\n// CLI execution\nif (require.main === module) {\n  (async () => {\n    try {\n      const broadcaster = new ActivityBroadcaster();\n      const input = await broadcaster.parseInput();\n      const result = await broadcaster.execute(input);\n      broadcaster.outputResult(result);\n    } catch (error) {\n      console.error(`Activity broadcaster error: ${error.message}`);\n      process.exit(1);\n    }\n  })();\n}\n\nmodule.exports = ActivityBroadcaster;","structuredPatch":[{"oldStart":19,"oldLines":7,"newStart":19,"newLines":7,"lines":["    * Parse input from Claude Code hook","    * @returns {Promise<Object>} Parsed hook input","    */","-  async parseInput() {","+  parseInput() {","     return new Promise((resolve, reject) => {","       let input = '';","       "]}],"userModified":false,"replaceAll":false}},"process_pid":161331,"parent_pid":161330,"working_directory":"/home/alejandro/Code/MCP/Hooks/Git/rins_hooks"}
